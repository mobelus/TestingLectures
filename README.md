# TestingLectures
Lestures for testing courses

https://habr.com/ru/post/549054/

# ОСНОВНОЕ
http://www.protesting.ru/testing/testdeliverables.html

# MD Format
https://github.com/tchapi/markdown-cheatsheet/blob/master/README.md

# НАЙТИ ВСЕ ССЫЛКИ НА САЙТЕ
- Поиск всех кликабельных Ссылок и Кнопок
- https://smallseotools.com/website-link-analyzer-tool/


# О REST Клиент-Сервере HTTP 
```
Представим себе 2 людей пишущих друг другу письма.
Клиент пишет письмо (Запрос) Серверу. Сервер пишет ответное письмо (Ответ) Клиенту.
Методы POST/PUT/GET/DELETE - МАРКИ на письмах. По цвету Макри Сервер понимает что это за письмо.
Письмо с Маркой POST и сервер уже сразу знает, что в письме будет инфа о том, что ему надо что-то создать.
Письмо с Маркой DELETE и сервер сразу понимает, что что-то надо удалить, а что именно удалить уже он прочитает в письме.
GET - не письмо, а открытка, ИБО ТЕЛА (самого пиьма как-бы нет, это был бы пустой конверт в котором письма НЕТ)
На открытке только Марка GET + Заголовок с URL - написано только то, что Клиент хочет запросить
```

### ? Адаптивный дизайн / Вёрстка
- Дизайн АДАПТИРУЮЩИЙСЯ = подстраивающийся под разные
- устройства (ПК, планшет, телефон), ширину/высоту экрана, прочее
- Изменяется не только в размерах что-то, но и трансформация элементов, скрытие и т.д.

### ? Кроссбраузерность
Работа в Разных Браузерах
- Интернет Эксплорер, ФайерФокс, Хром, Опера, Сафари

### ? Кроссплатформенность
Работа на разных Операционных системах
- Винда, Линукс, МАК, Мобилки
- Инструменты - ВИРТУАЛЬНЫЕ МАШИНЫ (программа симулирует работу компьютера с любой операционной системой)
- ВИРТУАЛЬНЫЕ МАШИНЫ - 1. WM Vare (платная) и 2. VirtualBox (бесплатная)

### ? HTML / CSS / javaScript
- HTML - язык вёрстки скелета сайта (в нём есть <ТЕГИ АТРИБУТЫ="Знач.Атр.">Знач.Тега</ТЕГИ> кнопки, слайдеры, ссылки это всё описано в html-коде)
- CSS - Файлы описания стилей (стили кнопок, контролов, других элементов сайта, в CSS-файлах описаны цвета/отступы/градиенты/размеры шрифтов и т.д.)
- javaScript - Прочие динамические красивости (файлы .js с кодом написанным на языке программирования javaScript)

### POSMAN:
Нужен для того чтобы **СФОРМИРОВАТЬ / ПОДГОТОВИТЬ / НАПИСАТЬ  ЗАААПРООООС**

В постмане мы пишем для запроса ЕГО
- REST-Метод (POST, PUT, GET, DELETE, CONNECT, и т.д. )
- ССЫЛКА = URL
- ЗАГОЛОВОК = HEADER
- ТЕЛО = BODY

Ссылку, Заголовок и Тело мы напишем Сами, а как их написать, мы прочитаем в Документации к Сайту или в описании API-сайта.


### DevTools:
- Просмотр HTML-разметки сайта (все теги, атрибуты всех элементов на сайте (кнопки, картинки, ссылки, и прочие элементы интерфейса сайта) )
- Консоль разработчика - Сами запросы и Коды ошибок (можно посмотреть подробности)
- Исходные коды сайта (не все только те что открыты) - некоторые папки, файлы, картинки и прочее что на сайте открыто
- Сеть - Все подробности про то какие HTTP-МЕТОДЫ отправлялись и получались. -  POST, PUT, GET, DELETE, CONNECT, и т.д. с КОДАМИ ответов 200, 400, 404, и т.д. можно смотреть в заголовки и тела запросов и ответов 
- Производительность
- Память (расход)
- Безопасность (шифрование)

# МЕТОДОЛОГИИ РАЗРАБОТКИ

### WATERFALL (Водопад), AGILE или SCRUM (Эджайл / Скрам), KANBAN (Канбан)

Подходы к организации командной работы. Мы рассматриваем командная работа = процесс разработки.

В процессе разработки у нас есть следующие участники:
1. Заказчик (Заказчик)
2. Менеджер (Исполнитель)
3. Аналитик
4. Программиста
5. Тестировщик

(1) **WATERFALL** - ВАТЕРФОЛ - ВОДОПАД - подход в следующем

1. Заказчик + Менеджер + Аналитик долго подготавливают БОЛЬШОЕ ТЗ (Требования (ФТ, НФТ, Документация / Спецификация) )
Они стараются учесть ВСЁ, что только нужно, чтобы разработчик написал полностью всю программу по этому ТЗ.
2. Разработчик получает 300 страниченое ТЗ, делает ПО не отрываясь 3 и более месяцев, заканчивает его и передает в тестирование
3. Тестировщик тестирует всё ПО по Спеке и всё.
4. Выпускаем продукт

- Плюсы: Исполнитель поэтапно выполняет большую глубоко проработанную Спецификацию. Легко идти "По ПЛАНУ" ...
- Минусы: Нет обратной связи с заказчиком. Изза недопониманий на любом этапе разработка может уйти не в ту сторону, и Заказчик в конце получит не то, что заказывал, а будет уже поздно.

(2) **AGILE** - ЭДЖАЙЛ - и **SCRUM** - СКРАМ -  методология / "гибкий подход" к разработке. Делать кусочками и постоянно иметь по каждому кусочку обратную связь с заказчиком.

Разбили разработку всего ПО на части

Часть_1,Часть_2,..., Часть_N
```
1 Часть = 1 Спринту
Один Спринт это 2 или 3 или 4 недели
За 1 спринт мы
1.1 планируем / распределяем подзадачи по команде
1.2 пишем ТЗ для части_1 
1.3 разрабатываем фичи для части_1 
1.4 тестируем фичи для части_1 
1.5 Показываем результат Спринта заказчику

и так по частям 

2 Часть = 2 Спринт
2.1 планируем / распределяем подзадачи по команде
2.2 пишем ТЗ для части_2 
2.3 разрабатываем фичи для части_2 
2.4 тестируем фичи для части_2 
2.5 Показываем результат Спринта заказчику

N-Спринтов и получаем
RELEASE!
```

(3) **KANBAN** - КАНБАН 

Есть Спринт - 2-3 недели
Задачи просто набор задач которые определили программисты
**РАЗНИЦА** между Скрамом в том, как распределяются задачи 

В **СКРАМЕ** за каждым разработчиком закреплены конкретные задачи СРАЗУ (с самого начла).

В **КАНБАНЕ** есть Корзина с задачами Общая, и каждый кто какую хочет, тот на протяжении Спринта берёт и выполняет

Задача и в **СКРАМЕ и КАНБАНЕ**, завершить к конце спринта все задачи



**Беклог** - задачи, которые не успели сделать в рамках спритна / Задачи которые появились новые в результате спринта / Задачи у которых понизился приоритет, которые можно будет сделать и потом, или вообще стали не обязательными (бантики / подвязка бантиков)



# ###################################
# JUNIOR # JUNIOR # JUNIOR # JUNIOR # 
# ###################################

# ВОПРОСЫ:

### ? - Какую литаретуру по тестированию читали ?
- Романа Савина - "тестирование дот ком"
- Святослав Куликов "Тестирование программного обеспечения. Базовый курс"
- SQL-ex на этом сайте исзучала SQL на практике

### ? - Что такое тестирование ПО ?

**Тестирование** – комплекс мероприятий, направленный на проведение 
проверок на соответствие производимого продукта требованиям, к нему предъявляемым (прямым и косвенным).

### ? - Цель тестирования 
**Цель тестирования** 
- проверили продукт на соотв. требованиям
- выявили (нашли и зафиксировали) ошибки
- контроль за тем, что ошибку устранили

— проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, 
поиск ошибок в программном обеспечении, которые должны быть выявлены до того, 
как их обнаружат пользователи программы.

### ? - Верификация и валидация

- **Верификация** (Verification) — это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, сформированным в начале этого этапа. 
- **Валидация** (Validation) — это определение соответствия разрабатываемого ПО ожиданиям и потребностям пользователя, требованиям к системе.

### ? - Что такое Дефект / Ошибка / Баг 
- факт несоответствия (прямым или косвенным) требованиям, продукта 
- с оценкой его критичности/серъёзности и Приоритета.

### ? - **ТИПЫ КРИТИЧНОСТИ Бага ТИПЫ Серьезности дефекта (Severity)**

- S1 Блокирующая = БЛОКЕР = Blocker - приложение в полностью нерабочем состоянии
- S2 Критическая (Critical) - система работает, НО не работает часть системы, обишка в ключевой бизнес логике, дыра в системе безопасности, и т.д.
- S3 Значительная (Major) - Ошибка не критична или есть возможность для работы с тестируемой функцией, используя другие входные точки.
- S4 Незначительная (Minor) - не нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.
- S5 Тривиальная (Trivial) - не касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная

### ? - **ТИПЫ Приоритета дефекта (Priority)**
- Высокий (High) - исправить как можно быстрее, ее наличие является критической для проекта.
- Средний (Medium) - исправить надо, НО ее наличие не является критичной.
- Низкий (Low) - исправить надо, НО ее наличие не является критичной, и НЕ требует срочного решения.

### ? - Приведите примеры Критического, Значительного и Незначительного бага.
Пример Интернет-магазин:
- S1 Блокер - упал сервер, сайт не работает
- S2 Упал раздел сайта, сам сайт работает, но целый раздел не доступен
- S3 На сайте всё работает, но неверно работает калькулятор суммы покупки, а сайтом и этой функцией пользуются вообще все покупатели
- S4 Сайт работет, но кнопка В корзину работает так, что пользователь не видит что он отправляет, ему приходится обновлять станицу, и тогда всё ок
- S5 НА последней странице сайта в разделе реквизитов компании в самом конце страницы виден артефакт вёрстки, какой-то лишний символ, но на него всем всёравно

### ? Шкала приоретизации ошибки / ШКАЛА Серьезности / ШКАЛА Приоритета Бага
https://www.software-testing.by/blog/bug-severity/

- У бага есть 1. **Серьезностиь** = КРИТИЧНОСТЬ дефекта + 2. **Приоритет**
- Количество пользователей которых затронул Баг Увеличивает Оба параметра  и Серъёзность и Приоритет (или понижает, если баг затронул мало)

Определяется **КОЛИЧЕСТВОМ ПОЛЬЗОВАТЕЛЕЙ**, которых **ЗАТРОНЕТ** конкретный БАГ. То есть Чем больший процент пользователей столкнулся с конкретным багом тем ВЫШЕ его Приоритет+Серьёзность сразу.

Пример:
1) По логину и паролю не могут с первого раза зайти 3 юзера из 10.000 .
2) 9.000 пользователей не могут зайти в аккаунт из 10.000

БАГ один и тот же, НО Приоритет + Серьёзность Для этих двух случаев СИЛЬНО РАЗНЫЕ.

(в каком-то смысле помним, что затронутые пользователи = количество денег которые будет терять бизнес)


### ? - Что такое СКВОЗНОЕ тестирование / E2E / End-To-End тестирование ?
- оно же End-to-end или E2E, — это процесс тестирования, при котором происходит подробная эмуляция пользовательской среды. Целью сквозного тестирования является создание полного производственного сценария. 

То есть при данном тестировании имитируют:
- щелчки мышью, 
- нажатия на кнопки, 
- заполнение форм, 
- переходы по страницам и ссылкам,
- и другие поведенческие факторы.

### ? Пирамида тестирования
Описывает эффективный подход к планированию и проведению тестирования. Она показывает как тесты делать, и сколько тестов и каких должно быть

```
       / \        максимально "дорого"
     / е2е \      ^
   /АПИ-тесты\    | ЦЕНА ПОДДЕРЖКИ | ПОКРЫТИЕ | ХРУПКОСТЬ СИСТЕМЫ |
 / ЮНИТ ТЕСТЫ \   V
/--------------\  максимально "дешёво"

<--количество--> 
    тестов
```

- **е2е** / ЕндТуЕнд тесты - мало - тесты графического интерфейса
- **АПИ-тесты** - Средне - их среднее число **их пишут тестеры**, которые подготавливает тестер, и тестирует их руками / или в автоматическом режиме при помощи Авто-тестов.
- **ЮНИТ ТЕСТЫ** - МНОГО - их больше всего и **их пишут программисты** прямо на этапе разработки (тестировщик на них не влияет, тестер только сообщает, что они упали/прошли). Они должны в самом начале ещё показать программисту, где у него в коде баг.

ПАРАМЕТРЫ у каждой ступени пирамиды такие: **ПОКРЫТИЕ**, **ЦЕНА ПОДДЕРЖКИ**, **ХРУПКОСТЬ СИСТЕМЫ**

**АПИ-тесты** - не графические а именно АПИ - подороже, ибо выявить баг сложнее, тестеру надо понять как баг воспроизвести, кодеру разобраться в написанном и решить проблему

**ЮНИТ-тест** - тест функций программного кода - максимально дешёво (для бизнеса, продуктом ещё никто не пользуется, а баги уже исправляются), кодер быстро правит сам, то что он легко заметит, легко устранит, и он даже не тратить времени на передачу нам в тестирование эти баги

### ? УРОВНИ тестирования (Их выделяют либо 3, либо 5)
Уровни тестирования ПО:
1. Модульное = Компонентное тестирование (тест отдельных компонентов / модулей от всей системы)
2. Интеграционное тестирование (корректно ли модули работают не отдельно друг от друга, а все вместе друг с другом)
3. Системное тестирование (проверка функциональных, и не функциональных требований, поиск дефектов в системе в целом)
4. Приемочное тестирование (проверка на соответствие требованиям чтобы проверить на сколько ПО готово к приёмке заказчиком)
5. Регрессионное тестирование (После внесения новых фич, не поломали ли эти новые фичи, что-то старое, работающее и уже отлаженное/протестированное)

### ? - Какие ВИДЫ (их всего 3 ВИДА) тестирования ты знаешь ?
1. **Функциональное**
2. **НЕФункциональное** 
3. **Сопровождения (связанные с изменениями)**


- **(1) Функциональное** (Верно ли работает ПО по функционалу (2+2=4)).
  - Смоук Дымное тестирование (поверхностное - тест на то работает ли впринципе)
  - Санити = Санитарное (проверка общего состояния системы в деталях, перед более тщательным тестированием)
  - Модульное = Компонентное = Блочное = Юнит = тестирование (проверка на корректность работы отдельных модулей исходного кода программы) 
  - Интеграционное тестирование - ПО состоит из нескольких модулей (они тестируются все вместе, как группа), проверяем корректность работы этих модулей друг с другом + обмена данными между ними. 
  - Пользовательское удобство (Юзабилити) - инуитивно понятен ли пользователю интерфейс и работа ПО вцелом
  - Тетисрование пользовательского интерфейса - всё ли работает так как по спецификации описано
  - Тестирование локализации (Как ПО подстраивается при смене языка пользователя)
  - Тестирование глобализации (Как ПО подстраивается к культуре пользователя)
  - Тестирование совместимости (Как ПО работает на другой ОС, другом железе, в другой пользовательской среде) и т. д.

- **(2) НЕФункциональное**  (Как/на сколько удобно юзеру (удобно ли юзеру/рам видеть 2 + 2 = 4 или 2+2=4 и т.д.)).
  - **Тестирование безопасности** - **(?)** (а может это функц тестир. ? СМ НИЖЕ **(НЮАНС 1)**)) 
  - **Нагрузочное тестирование** - плавное повышение нагрузки - **(?)** (а может это функц тестир. ? СМ НИЖЕ **(НЮАНС 2)**))
  - Стрессовое тестирование (когда нагрузка на систему скачкообразное)
  - Производительности / Тестирование на производительноcть (как быстро работает система под строго определённой нагрузкой)
  - Тестирование стабильности / надёжности (длительное время с средней нагрузкой)
  - Объемное тестирование (проверка работы при больших объёмах данных)
  - Тестирование масштабируемости (способность системы запрашивать/включать доп. мощности)
  - Приёмочное тестированиеи (на этапе сдачи готового продукта заказчику)
  - Тестирование на отказ и восстановление (как система восстановится, после отказа оборудования, сбоев в сети, проблемах в связи)
  - Тестирование Утсановки т.д.

- **(3) Сопровождения (связанные с изменениями)**
  - Регрессионное - Проверка на то, не роняет ли разработанная сейчас фича, то, что безошибочно работало ранее. (в уже оттестированное ПО добавили фичу, надо проверить не поломала ли новая фича работоспособность старых фич, уже отлаженных и корректно работающих)
  - Тестирование на эксплуатации
  - 
--------------------------------------------
**(НЮАНС 1)**
- Строго говоря - **Тестирование безопасности** - это НЕФункциональное тестирование, НО
- АНТИВИРУС - ЕСЛИ основной функцией ПО/Веб-сервиса - обеспечивать Безопасность, ТО тестирование на безопасность можно для него считать Функциональным

**(НЮАНС 2)**
- Строго говоря - **Нагрузочное тестирование** - это НЕФункциональное тестирование, НО
- БАЛАНСИРОВЩИК - ЕСЛИ основной функцией ПО/Веб-сервиса - держать нагрузку, ТО нагрузочное тестирование можно для него считать Функциональным
-------------------------------------------
	
**Прочее: Методы и Типы тестирования**
- АВТО матическое тестирование / Ручное тестирование
- Тестирование методом Чёрного / Серого / Белого Ящика (-)(+)
- Тестирование Негативное / Позитивное
- Статическое - проверяем не приложение, а документацию к нему, графические прототипы, схемы и прочее
- Динамическое - проверяем запущенное работающее приложение


### ? - Дымовые (Smoke)
Цель — проверить «стабильность» системы в целом,

### ? - Санити (Sanity) Санитарное тестирование
- Целью является проверить общее состояние системы в деталях, перед более тщательным тестированием

### ? - Регрессионное 
- Цель — убедиться что свежие изменения в коде не оказали побочных эффектов на устоявшуюся работающую функциональность

### ? - Ре-тест 
- Цель - выяснить, что ранее заявленные тест кейсы все проходят - проверяет что дефект исправлен (Прошли по всем тесткейсам с первого по последний)

### ? - Интеграционное 
- как существующие модули работают друг с другом - (4 блока сайта, работает ли корректно обмен данными по протоколу между ними, не вызывют они ошибок в работе друг друга)

# ? - Что такое Техники тест-дизайна ?
1. Эквивалентное разделение (Equivalence Partitioning)
2. Граничные значения (Boundary Values)
3. Таблица принятия решений (Desicion Table) = Матрица принятия решений
4. Парное тестирование (Pairwise Testing)
5. Причина и следствие
6. Диаграмма перехода состояний (State-transition Diagram)
7. Диаграмма пользовательских ролей (Use Case Diagram)
8. Предугадывание / Угадывание ошибок (Error Guessing)
9. Исследовательское тестирование (Exploratory Testing) 

### ? - Что такое Техники тест-дизайна ? ПРИМЕРbl:
На сайте для покупки билетов рассмотрим возрастные группы для которых есть разные цены билетов и разные льготы для разных возрастов:

Возрастные группы : Дети (0-15 лет), Молодые (15-25 лет), Взрослые (25-60 лет) Старики (60-99 лет) В поле ввода возраста можно ввести от 0 до 99, только 2 ЦИФРЫ

- **Эквивалентное разделение** (один и тот же результат теста для одной эквивалентной группы параметров - что 0, что 1, что 2, что 15 - будет ребёнок) Пример: Возрастные группы и покупка билетов:
  - Дети (0-15 среднее = 10), 
  - Молодые (15-25 ср.=18), 
  - Взрослые (25-60 ср.=35), 
  - Старики (60-99 ср.=75)

- **Граничные значения** (большинство ошибок будет на границах - нужно тестить 3 значения - 1. саму границу 2. на единицу больше границы 3. на единицу меньше границы)
  - Дети (0-15 граничные = 0/1 + 14/15/16), 
  - Молодые (15-25 гр. = 14/15/16 + 24/25/26), 
  - Взрослые (25-60 гр. = 24/25/26 + 59/60/61), 
  - Старики (60-99 гр. = 59/60/61 + 98/99/100 - хоть 100 и нельзя внести, но можно попробовать)

- **Таблица принятия решений** (Desicion Table) = Матрица принятия решений. Пример таблицы для 2-ух факторной авторизации (возможные сценарии):
  1. Правильный логин и правильный пароль.
  2. Правильный логин, неправильный пароль.
  3. Неправильный логин, правильный пароль.
  4. Неправильный логин, неправильный пароль.

- **Парное тестирование** (Pairwise Testing) https://habr.com/ru/company/otus/blog/592575/

Суть: **Большинство дефектов как правило вызвано взаимодействием не более двух факторов** (дефекты, которые возникают при взаимодействии трех и более факторов, как правило менее критичны). Следовательно, выбирается пара двух тестовых параметров, и все возможные пары этих двух параметров отправляются в качестве входных параметров для тестирования. Pairwise testing сокращает общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные на тестирование.

ПРИМЕР: Магазин автомобилей с двумя полями: 
- *Марка автомобиля* [а. BMW б. Audi в. Nissan]
- *Регистрационные номера* [а. Валидные (5000) б. Невалидные]

Судя по описанию потенциальных входных данных для теста будет 3 Х 5000 = 1500 это мы ещё не учли невалидные, которых не понятно сколько нужно взять для теста.

Парное тестирование выделит всего 2 типа номеров: валидный и невалидный Регистрационный номер, и проверять мы будем только по одному валидному и одному невалидному. для каждой Марки автомобиля. В итоге получим такую таблицу Пар:

Модель|	Рег.Номер  |
----- |  --------- | 
BMW   |	Валидный   | 
BMW   |	Невалидный | 
Audi  |	Валидный   | 
Audi  |	Невалидный | 
Nissan|	Валидный   |
Nissan|	Невалидный | 

Итого вместо  3 Х 5000 = 1500 потенциальных тестов

Мы получили всего  3 Х 2 = 6 тестов 

- **Причина и следствие**
Примеры:
1. Тыкнули в чекбокс - посмотрели, что у него проставилась галочка
2. Нажать крестик в правом верхнем углу окна (причина), оно закроется (следвтие)

- **Диаграмма перехода состояни**

Тестируем выключатель света в комнате

| свет горит |  выключить свет ->  | темнота |

| свет горит | <- включить свет    | темнота |

**Исследовательское и Интуитивное тестирование**
- Логика + Здравый смысл
- Собственный пользовательский опыт
- Применить опыт и знания о работе Аналогичного продукта



# ? Чек-лист / Тест-Кейс / Баг Репорт
### ? - Разница между Тест-кейсом и Чек-листом и Баг-Репортом ?
- Чек-лист - (2) - Таблица из обычно двух стобцов с Только  1. заголовками тестов 2. столбец для Галок / Крестов, чтобы отмечать Пройдент Тест или Нет
- Тест-кейс - (3) - содержит в себе 1. заголовок / описание теста 2. Шаги воспроизведения кейса 3. Ожидаемый + Фактический результат 4. Скрины 5. Видеозапись
- Баг Репорт - (6) - 1. Короткое описание 2. Серьезность 3. Приоритет (очередь исправления ошибки). 4. Статус (из жизненного цикла). 5. Шаги воспроизведения 6. Фактический результат + Ожидаемый результат

### ? - Автоматизация на проекте ?
- По поводу автоматизации на питоне / джаваскрипте ?
- Программировать пробовала или нет ещё ?

### ? - Жизненный цикл ПО:

1. анализ требований к проекту
2. проектирование
3. реализация
4. тестирование продукта
5. внедрение и поддержка

### ? - ЖЦБ - Жизненный цикл Бага:

http://www.protesting.ru/testing/bug_lifecycle.html

СОСТОЯНИЯ БАГА:
0. Обнаружен
1. 1.1 Открыт 1.2 Отклонён 1.3 Отсрочен
2. Переоткрыт 
3. Исправлен
4. Закрыт

Варианты Жизненного цикла Бага:
- Классика 1: 0. Обнаружен -> 1.2 Открыт -> 3. Исправлен -> 4. Закрыт
- Классика 2: 0. Обнаружен -> 1.2 Открыт -> 3. Исправлен -> 2. Переоткрыт -> 3. Исправлен -> 2.-> 3.-> ... -> цикл пока не -> 3. Исправлен Окончательно -> 4. Закрыт
- Не редко: 0. Обнаружен -> 1.2 Отклонён -> 4. Закрыт
- Не редко: 0. Обнаружен -> 1.3 Отсрочен -> 4. Закрыт
- Тоже бывает: 0. Обнаружен -> 1.2 Отклонён -> 4. Переоткрыт -> Начинаем цикл с Открыт


### ? - ПредПРОД = ПРЕД ПРОДАКШН:
- ПРЕД ПРОД **СТЕНД** - в идеале, это **СРЕДА** идентичная или максимально приближенная к продуктивной: те же данные, то же аппаратно-программное окружение, та же производительность. Она используется, чтобы сделать финальную проверку ПО в условиях максимально приближенным к «боевым».

### ? - Тестовый Стенд от Продакшн-стенда:
- Тестовый СРЕДА для проверок, которые иммитируют боевой стенд

### ? - DEV Стенд от слова DEVELOPER:
- стенд разработки на нем непрерывно появляются новые версии от разрабов

### ===============================================
### https://blog.skillfactory.ru/glossary/rest-api/
### ===============================================

### ? - Клиент Серверная архитектура / Клиент Серверное взаимодействие:
ОТВЕТ: 
- **Клиент** это как правило сторона на которой работает Пользователь (например с Сайтом через Браузер). **Сервер** это как правило сторона где находится сам сайт, который как правило работает на своей стороне с **БАЗОЙ ДАННЫХ** сайта
- Общение между Клиентом и Сервером как правило работает через систему **ЗАПРОСОВ** и **ОТВЕТОВ** (Клиент отправляет запросы, сервер их примнимает (ПАРСИТ = смотрит содержимое - выясняет что клиенту нужно) и сервер подготавливает и отправляет клинту ответы, клиент получает ответы (ПАРСИТ = смотрит содержимое - и понимает что ему ответил сервер).
- Бывают разные варианты клиент-серверных взаимодейтсвий:

(клиент) один-один (севрер)

_________ один-много

_________ много-один

(клиентов) много-много (серверов)

### ? - Как пользователь (клиент) Запрашивает данные?
- При помощи HTTP запросов

### ? - Как происходит обмен между Клинтом и Сервером ?
### ? -Как может общаться между собой Клиент и Сервер ?
### ? - Какими структурами данных может общаться между собой Клиент и Сервер ?
- JSON -ами
- XML -ями
- Теоретически ещё и обычным текстом безо всяких форматов (если так захотел разработчик)
- Через Запрос - Ответ (А в запросах и ответах уже всё, что назвали выше JSON, XML, обычный текст)

### ? - Разница между Бек и Фронт / Бэк и Фронт / Бек и Фронт:
- Фронт - графическое представление сайта, то с чем работает обычно пользователь руками+мышкой+клавой
- Бэк - всё, что находится на серверной стороне сайта. Исходный код сайта + База данных сайта.

### ? - JSON (умеет хранить древовидные структуры)
- хранит всё парами **КЛЮЧ** : **ЗНАЧЕНИЕ**
```
{
  "ключ_1": "значение-строка",
  "ключ_2": 1234, // значение число
  "ключ_5": [ 1, 2, 3], // значение массив // значения в массиве через запятую
}
```

### ? - XML (умеет хранить древовидные структуры)
- хранит всё как **<ТЕГ>ЗНАЧЕНИЕ</ТЕГ>** 
- <**тег**-открывающий>*значение_тега*</**тег**-закрывающий>
- <тег>значение_тега</тег>
- <тег **атрибут_1** = значение_атрибута_1, **атрибут_2** = значение_атрибута_2 > значение_тега </тег>
- Теги стоят в треугольных скобках, а значение тега стоит между тегами
- Атрибуты (свойства) - стоят всегда в открывающем теге сразу после имени открывающего тега


# API

### ? - Что такое API: 
ОТВЕТ:
- это в первую очередь **ФУНКЦИИ**, которые делаются для Внутреннего или Внешнего использования
- ВНУТРЕННЕЕ АПИ - не доступно в Глобальном интернете (не смотрит наружу) - Внутреннее, это когда например внутри предприятия мы тестируем апи сайта нашего банка или страховой компании (мы не хотим чтобы ктото кроме нас получил доступ к счетам, банковским реквизитам и т.д. и нам программисты системы дают какое-то АПИ, для использования только внутри сети предприятия.)
- ВНЕШНЕЕ АПИ - Досупно всем в Глобальной сети интернет (смотрит наружу) - Когда мы хоти написать свой сайт и чтобы на нашем сайте был блок который показывает погоду, мы можем воспользоваться ВНЕШНИМ АПИ Яндекс Погоды или ГУГЛ-погоды и т.д. (эти сайты свободно дают инфу о погоде через своё внешнее апи)


### ? - Что такое API ... ЕЩЁ: 
ОТВЕТ:
- API ... ЕЩЁ - Это своеобразный КОНТРАКТ, в котором описан набор "Рекомендаций" по тому как должны работать между собой приложения и сервисы.
- Например Есть REST-API и SOAP-API.

# REST и SOAP / REST-API и SOAP-API

## REST
- Не стандарт - архитектурный стиль (набор рекомендаций как должна работать передача данных)
- пример **REST** это HTTP-протокол
- МЕНЕЕ безопасный и защищённый, чем SOAP (слишком много вольностей +GET например нельзя передавать пароли)
- только клиент-серверная архитектура и только на HTTP
- cостояние клиента не сохраняется на сервере
- обмен данными - **Разные типы данных JSON, XML, просто текст, Картинки, любой формат данных**

## SOAP 
- Стандарт (набор жёстких и строгих описаний как должна работать передача данных)
- пример **SOAP** это WSDL-протокол
- БОЛЕЕ безопасный и защищённый (безопасность в строгости и том что удобно можно передавать секретные данные, пароли и т.д. и быть уверенным в их сохранности)
- не только клиент-серверная архитектура, и не только HTTP, он поддерживает работу с многими другими протоколами по мимо HTTP
- очень строгий по своему формату и сильно запротоколизированный
- обмен данными - **только XML** только кокнретного формата


### ? - Что такое REST:
ОТВЕТ: 
- Это такой КОНТРАКТ, который представляет собой набор 
"Рекомендаций" по тому как должны работать между собой приложения и сервисы
- Общение происходит между Клиентом и Сервером
- Общение должно происходить путём Запросов и Ответов
- Для общения должны использоваться REST-методы

### ? - МЕТОДЫ REST: https://htmlacademy.ru/blog/best/get-vs-post

В REST API есть 4 метода HTTP, которые используют для действий с объектами на серверах:

- **DELETE** - **удалить** объект (на сервре)
- **POST** - **создать** объект (на сервере)
- **PUT** - **обновить** объект (объект уже есть, а мы перезаписываем его на сервере)
- **GET** - **запросить/получить** объект (запросить и получить в ответе информацию об объекте)

### ----------------

- DELETE <=> ответ 200 OK / 202 Принято (в процессе удаления) / 204 Нет Контента (нечего удалять)
- POST   <=> ответ 201 Создано (обязательно, ибо объекта не было изначально)
- PUT    <=> ответ 201 Создано (PUT создаёт, если не находит) / 200 ОК (если нашёл и обновил) /  204 Нет контента (если ресурс обновлялся)
- GET    <=> ответ 200 OK (Данные найдены и отправлены в ответе)

```
Например, чтобы обновить видео про Python по адресу 
http://school.ru/python/2.avi
REST API будет использовать метод PUT, 
а для его удаления — DELETE.
```

# https://qsusha.wordpress.com/2017/10/29/%D1%8D%D1%82%D0%BE-%D1%81%D0%BC%D0%B5%D1%88%D0%BD%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-%D0%B8%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B9/

## ? - Чем отличается POST от PUT / PUT от POST:

### ОТВЕТ: **POST** - **создаёт объект** (на сервере), которого **НЕ БЫЛО РАНЬШЕ** <=> **PUT** - **обновляет УЖЕ СУЩЕСТВУЮЩИЙ объект** ИЛИ создаст новый, если не нашёл, то что надо было обновить.

- **POST** - **создать объект** (на сервере), которого на сервере ЕЩЁ НЕТ **В КАЖДЫЙ СВОЙ ВЫЗОВ**. Если выполним 10 раз один и тот тоже POST, то создастся 10 идентичных записей - ответ 201 Создан
- **PUT** - **обновить УЖЕ СУЩЕСТВУЮЩИЙ объект ЦЕЛИКОМ**, мы перезаписываем его на сервере **(!!!) ИЛИ PUT Создаёт новый**, если такого объекта ещё нет [ответ 200 OK если обновили, и 201 если создали]

## ? - Чем отличается POST от GET / Чем отличается GET от POST:

### ОТВЕТ: У **POST ЕСТЬ ТЕЛО** (BODY) <=> у **GET - НЕТУ ТЕЛА** (BODY) только URL и заголовок

- **POST** - **создать объект** (на сервере), которого на сервере ЕЩЁ НЕТ **В КАЖДЫЙ СВОЙ ВЫЗОВ**. Если выполним 10 раз один и тот тоже POST, то создастся 10 идентичных записей - ответ 201 Создан
- **GET** - **запросить** и получить в ответе **информацию об объекте** - ответ 200 OK

#

### ? - ЕСТЬ ЛИ ЕЩЁ ДРУГИЕ МЕТОДЫ REST:
- В REST обычно указываются основные 4: **DELETE, POST, PUT, GET**
- НО В **HTTP ВСЕГО 9 МЕТОДОВ** - 4 из пункта выше И **ещё 5** методов: **HEAD, OPTIONS, PATCH, TRACE, CONNECT**

- **GET** - НЕТ ТЕЛА - нужен для запроса/получения ответа от сервера (изменений не вносит)
- **HEAD** - то же, что и GET, но без Тела запроса только Заголовок (изменений не вносит)

- **PUT** - обновляет уже cуществующий объект ЦЕЛИКОМ и может создавать новый, если его нет
- **PATCH** - обновляет уже cуществующий объект ЧАСТИЧНО (объект и его данные)

- **CONNECT** - преобразует существующее соединение в тоннель.
- **OPTIONS** - получить параметры текущего HTTP соединения.

- **TRACE** - применяется для диагностики, он позволяет видеть клиенту, что происходит в 
каждом звене цепочки между компьютером клиента и конечным получателем.



### ? - Коды HTTP - https://developer.mozilla.org/ru/docs/Web/HTTP/Status

```
100 - Продолжить
101 - Переключение протокола
102 - В обработке
200 - Успешно
201 - СОЗДАН - Объект создан после того как выполнили метод POST (но может и от PUT)
202 - ПРИНЯТО - Запрос принят, но ещё не обработан.
300 - Множественный ответ
302 - Найдено - Объект был временно изменён
304 - Не модифицировано - для кэширования
400 - Плохой запрос - НЕУСПЕХ скорее всего опечатались в адресе
401 - Ошибка авторизации - Ошибка авторизации пользователя
403 - Запрещено - Клиенту запрещено нет прав для доступа к объекту
404 - Не найдено - То что нужно Клиенту не нашлось - объект не найден
500 - Внутренняя ошибка Сервера
501 - Метод не поддерживается на Сервере 
502 - Когда сервер используется как шлюз не получил ответ от основного сервера
503 - Сервис недоступен
```

```
- 100 - Продолжить
- 101 - Переключение протокола
- 102 - В обработке

- 200 - OK - "Успешно". Запрос успешно обработан.
- 201 - Created - "Создано". Запрос успешно выполнен и в результате был создан ресурс. Этот код обычно присылается в ответ на запрос PUT "ПОМЕСТИТЬ".
- 202 - Accepted - "Принято". Запрос принят, но ещё не обработан. Не поддерживаемо, т.е., нет способа с помощью HTTP отправить асинхронный ответ позже, который будет показывать итог обработки запроса. Это предназначено для случаев, когда запрос обрабатывается другим процессом или сервером, либо для пакетной обработки.
- 203 - Non-Authoritative Information - "Информация не авторитетна". Этот код ответа означает, что информация, которая возвращена, была предоставлена не от исходного сервера, а из какого-нибудь другого источника. Во всех остальных ситуациях более предпочтителен код ответа 200 OK.
- 204 - No Content - "Нет содержимого". Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются. Клиент может использовать их для обновления кешированных заголовков полученных ранее для этого ресурса.
- 205 - Reset Content - "Сбросить содержимое". Этот код присылается, когда запрос обработан, чтобы сообщить клиенту, что необходимо сбросить отображение документа, который прислал этот запрос.
- 206 - Partial Content - "Частичное содержимое". Этот код ответа используется, когда клиент присылает заголовок диапазона, чтобы выполнить загрузку отдельно, в несколько потоков.

- 300 - Multiple Choice - "Множественный выбор". Этот код ответа присылается, когда запрос имеет более чем один из возможных ответов. И User-agent или пользователь должен выбрать один из ответов. Не существует стандартизированного способа выбора одного из полученных ответов.
- 301 - Moved Permanently - "Перемещён на постоянной основе". Этот код ответа значит, что URI запрашиваемого ресурса был изменен. Возможно, новый URI будет предоставлен в ответе.
- 302 - Found - "Найдено". Этот код ответа значит, что запрошенный ресурс временно изменен. Новые изменения в URI могут быть доступны в будущем. Таким образом, этот URI, должен быть использован клиентом в будущих запросах.
- 303 - See Other- "Просмотр других ресурсов". Этот код ответа присылается, чтобы направлять клиента для получения запрашиваемого ресурса в другой URI с запросом GET.
- 304 - Not Modified - "Не модифицировано". Используется для кэширования. Это код ответа значит, что запрошенный ресурс не был изменен. Таким образом, клиент может продолжать использовать кэшированную версию ответа.
- 305 - Use Proxy - "Использовать прокси". Это означает, что запрошенный ресурс должен быть доступен через прокси. Этот код ответа в основном не поддерживается из соображений безопасности.
- 306 - Permanent Redirect - "Перенаправление на постоянной основе". Это означает, что ресурс теперь постоянно находится в другом URI, указанном в заголовке Location: HTTP Response. Данный код ответа имеет ту же семантику, что и код ответа 301 Moved Permanently, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если POST использовался в первом запросе, POST должен использоваться и во втором запросе.

- 400 - Bad Request - "Плохой запрос". Этот ответ означает, что сервер не понимает запрос из-за неверного синтаксиса.
- 401 - Unauthorized - "Неавторизовано". Для получения запрашиваемого ответа нужна аутентификация. Статус похож на статус 403, но,в этом случае, аутентификация возможна.
- 402 - Payment Required - "Необходима оплата". Этот код ответа зарезервирован для будущего использования. Первоначальная цель для создания этого когда была в использовании его для цифровых платежных систем(на данный момент не используется).
- 403 - Forbidden - "Запрещено". У клиента нет прав доступа к содержимому, поэтому сервер отказывается дать надлежащий ответ.
- 404 - Not Found - "Не найден". Сервер не может найти запрашиваемый ресурс. Код этого ответа, наверно, самый известный из-за частоты его появления в вебе.

- 500 - Internal Server Error - "Внутренняя ошибка сервера". Сервер столкнулся с ситуацией, которую он не знает как обработать.
- 501 - Not Implemented - "Не выполнено". Метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые сервера должны поддерживать (и, соответственно, не должны возвращать этот код) - GET и HEAD.
- 502 - Bad Gateway - "Плохой шлюз". Эта ошибка означает что сервер, во время работы в качестве шлюза для получения ответа, нужного для обработки запроса, получил недействительный (недопустимый) ответ.
- 503 - Service Unavailable - "Сервис недоступен". Сервер не готов обрабатывать запрос. Зачастую причинами являются отключение сервера или то, что он перегружен. Обратите внимание, что вместе с этим ответом удобная для пользователей(user-friendly) страница должна отправлять объяснение проблемы. Этот ответ должен использоваться для временных условий и Retry-After: HTTP-заголовок должен, если возможно, содержать предполагаемое время до восстановления сервиса. Веб-мастер также должен позаботиться о заголовках, связанных с кэшем, которые отправляются вместе с этим ответом, так как эти ответы, связанные с временными условиями, обычно не должны кэшироваться.
- 504 - Gateway Timeout - Этот ответ об ошибке предоставляется, когда сервер действует как шлюз и не может получить ответ вовремя.
- 505 - HTTP Version Not Supported - "HTTP-версия не поддерживается". HTTP-версия, используемая в запроcе, не поддерживается сервером.
```


### ? - Если был выполнен запрос с кодом 201 и какой метод был выполнен ?

**201 = СОЗДАН** - Объект был успешно создан. И этот код был получен после того как выполнили скорее всего метод **POST**


### ? - Разница между HTTP и UDP:
- HTTP - гарантирует доставку и получение (медленнее чем UDP, зато надёжнее)
- UDP просто отправляет в одну сторону и не ждёт подтвержедение о доставке (ненадёжен, зато быстрее чем HTTP)

### ? - Разница между HTTP и HTTPS:
- HTTPS Более безопасный чем старый HTTP, ибо HTTPS работает через СЕРТИФИКАТ (Сертификат означает, что ресурсу (сайту) можно "доверять")
- HTTPS имеет Защита от хакерских атак, направленных на **прослушивание** соединения;
- Не страшно передавать пароли, банковскую и другую личную инфу ибо она более защищена

### ? - Что такое КУКИ ?

### ? - Что такое КЭШ ?

### ? - Что такое Аутентификация и Авторизация и Идентификация:

- **Аутентификация** - логин + пароль - подтверждение подлинности пользователя
- **Авторизация** - предоставление прав пользователю
- **Идентификация** - предоставление только логина (совего уникального имени)

### ? - Что такое База Данных ?

1. База данных это **хранилище информации** (например PostgreSql, ORACLE, MySql, MSSQL).
2. Хранятся **данные в Таблицах**. У таблиц есть **столбцы + строки + ячейки** (пересечение столбца и строки).
3. Таблицы бывают **с отношениями** (с другими таблицами), а бывают Таблицы **без отношений**.

Отношения: 3.1 **один-к-одному** 3.2 **один-ко-многим** 3.3 **многие ко многим**

4. Таблицы ещё обычно приводятся к 1-ой, к 2-ой и третей НОРМАЛЬНОЙ ФОРМЕ.

НОРМАЛЬНЫЕ ФОРМЫ - позволяют построить таблицы так, чтобы избежать избыточности инфы в таблицах.

```
ОТНОШЕНИЯ ПРИМЕР:
_____________________________________________________________________________________________
многие ко многим | Учителя - Предметы    | 
Учитель А по Физре и Истории, и в той же школе ещё 2 разных учителя Б и В и оба по Труду

один-ко-многим | Люди    - Телефоны    | 
Телефон принадлежит только одному человеку. НО Человеку принадлежит много разных телефонов

один-к-одному | Сотрудники - ДНК-коды | 
Сотрудники А, Б, В и у каждого сотрудника свой отдельный уникальный код ДНК
```

### ? - Что уже писали на SQL, запросы какого рода

0. Училась на сайте SQL-EX

писала:
1. SELECT FROM WHERE
2. SELECT в SELECT-е
3. JOIN-ы

### ? - Нужны ли отношение между таблицами, когда мы делаем JOIN

НЕТ - JOIN можно использовать для любых двух таблиц (не обязательно чтобы был связующий столбец или какая-то связь)

Важно - Столбцы у таблиц, которые СКЛЕИВАЕМ JOIN-ом должны быть одинакового ТИПА 


# ###################################
# MIDDLE # MIDDLE # MIDDLE # MIDDLE # 
# ###################################


### ? - Чем отличается POST от PUT / PUT от POST:

- **POST** - создать объект (на сервере), которого на сервере ЕЩЁ НЕТ **В КАЖДЫЙ СВОЙ ВЫЗОВ**. Если выполним 10 раз один и тот тоже POST, то создастся 10 идентичных записей - ответ 201 Создан
- **PUT** - обновить объект, который уже есть, а мы перезаписываем его (на сервере) **ИЛИ создать** новый, если мы не нашли указанный - ответ 200 OK (нашёл+обновил) / ответ 201 Создан (не нашёл => создал)

РАЗНИЦА:

1. POST создаёт объект, которого на сервере ЕЩЁ НЕТ 

<=> PUT - обновляет объкт, который на сверере УЖЕ СУЩЕСТВУЕТ (если его не существует, PUT его Создаст)

2. POST в случае успеха всегда должен возвращать статус 201 (Created) и Location на новый ресурс.

<=> PUT же может возвращать как 201 (если ресурс не найден), так и 204 (No Content) — если ресурс обновлялся.

3. POST - НЕИдемпатентный - каждый раз создавая НОВЫЙ объект мы в ответе получаем РАЗНЫЙ ответ с новой инфой о новом объекте -  в свою очередь, может создавать новые объекты при последовательных запросах на один урл.

<=> PUT - ИДЕМПАТЕНТНЫЙ - каждый раз получаем в ответе ОДНУ и ТУЖЕ информацию об объекте который обновили - т.е. несколько одинаковых последовательных пут-запросов на один урл (и с одинаковыми параметрами) НЕ создают новых объектов.

### ? - Чем отличается POST от GET / Чем отличается GET от POST:

- **POST** - создать объект (на сервере), которого на сервере ЕЩЁ НЕТ **В КАЖДЫЙ СВОЙ ВЫЗОВ**. Если выполним 10 раз один и тот тоже POST, то создастся 10 идентичных записей - ответ 201 Создан
- **GET** - запросить/получить в ответе информацию об объекте (создать объект через GET тоже как-то можно!)

РАЗНИЦА:
**1. (!!!) ЭТО ОСНОВНОЕ (!!!) POST - есть ТЕЛО (BODY) <=> GET - НЕТУ ТЕЛА (BODY)**

2. POST Более Безопасный (пароли/банковские карты/файлы), Параметры размещаются в ТЕЛЕ (BODY)

<=> GET - Небезопасный - ибо КЭШИРУЕТСЯ (остаётся в памяти) - (пароли в нём лучше не передавать) Параметры передаются в URL-е (используются чаще всего для фильтрации)

3. POST - Ограничен только теми размерами которые задаст программист (а так ограничений в длинне URL НЕТ)

<=> GET - ОРГАНИЧЕН по длинне URL-а (2048 символов)

4. ИДЕМПАТЕНТНОСТЬ - когда мы делая одно и то же действие (тот же метод,действие,теже параметры,и т.д.) получаем один и тот же результат

Если результат разный, при одном и том же выполнении метода, то он НЕИДЕМПАТЕНТНЫЙ

POST - НЕИдемпатентный - каждый раз создавая НОВЫЙ объект мы в ответе получаем РАЗНЫЙ ответ с новой инфой о новом объекте

<=> GET - ИДЕМПАТЕНТНЫЙ - каждый раз получаем в ответе ОДНУ и ТУЖЕ информацию об объекте который запросили

### ? - ИДЕМПАТЕНТНЫЙ метод

- POST - НЕИдемпатентный - каждый раз создавая НОВЫЙ объект мы в ответе получаем РАЗНЫЙ ответ с новой инфой о новом объекте
- PUT - ИДЕМПАТЕНТНЫЙ - каждый раз получаем в ответе ОДНУ и ТУЖЕ информацию об объекте который обновили
- GET - ИДЕМПАТЕНТНЫЙ - каждый раз получаем в ответе ОДНУ и ТУЖЕ информацию об объекте который запросили
- DELETE - ИДЕМПАТЕНТНЫЙ - 1 раз - удаляем, получаем ОК | 2,3,..,N раз - удаляем ничего не происходит, формально это тоже ОК

ИДЕМПАТЕНТНЫЕ - GET, HEAD, PUT и DELETE. Так же эффектом идемпотентности обладают HTTP методы OPTIONS и TRACE.


### ? - Коды HTTP - https://developer.mozilla.org/ru/docs/Web/HTTP/Status

```
100 - Продолжить
101 - Переключение протокола
102 - В обработке
200 - Успешно
201 - СОЗДАН - Объект создан после того как выполнили метод POST (но может и от PUT)
202 - ПРИНЯТО - Запрос принят, но ещё не обработан.
300 - Множественный ответ
302 - Найдено - Объект был временно изменён
400 - Плохой запрос - НЕУСПЕХ скорее всего опечатались в адресе
401 - Ошибка авторизации - Ошибка авторизации пользователя
403 - Запрещено - Клиенту запрещено нет прав для доступа к объекту
404 - Не найдено - То что нужно Клиенту не нашлось - объект не найден
500 - Внутренняя ошибка Сервера
501 - Метод не поддерживается на Сервере 
502 - Когда сервер используется как шлюз не получил ответ от основного сервера
503 - Сервис недоступен
```


### ? - POST - можно ли удалить данные ?
- ДА, передаём в URL или в ТЕЛО id того, что хотим удалить.
### ? - PUT - можно ли удалить данные ?
- ДА, - отправляем PUT с пустой строкой и эта пустая строка запишется на месте нашего объекта, который обновили через PUT.
### ? - GET - можно ли удалить данные ?
- ДА, передаём в URL id того, что хотим удалить, например /delete/1 или /delete.php?id=1 (1 - это значение id).

#

# ###################################
# MIDDLE # MIDDLE # MIDDLE # MIDDLE # 
# ###################################





# CREATE INSERT SELECT UPDATE DELETE (DROP)

- 1 -- СОЗДАНИЕ ТАБЛИЦЫ БД
**CREATE** TABLE "имя_таблицы" ( имя_столбца_1 тип_стоблца_1, имя_столбца_2 тип_стоблца_2, ..., имя_столбца_N тип_стоблца_N );

```
CREATE TABLE "shop"
(
	  id INT primary key
	, price INT
	, name text
)
WITH(OIDS=FALSE);
ALTER TABLE "shop" owner to postgres;
```
- 2 -- ВСТАВКА ЗНАЧЕНИЙ В ТАБЛИЦУ БД

**INSERT INTO** таблица (столбцы) VALUE (значения)

```
-- INSERT INTO "имя_таблицы" ( имя_столбца_1, имя_столбца_2, ... имя_столбца_N) 
-- VALUE (знач_1, знач_2, ... знач_N), -- значения для строки 1
--       (знач_1, знач_2, ... знач_N), -- значения для строки 2
--		  ...
--       (знач_1, знач_2, ... знач_N); -- значения для строки N
```

```
INSERT INTO
 public."shop" (id, price, name)
VALUES
 (1,  700, 'платье'),
 (2,  200, 'ботинки'),
 (3,   10, 'носки'),
 (4, 1000, 'штаны'),
 (5,  200, 'шарф')
;
```
- 3 -- УДАЛЕНИЕ Записи БД

-- **DELETE** FROM "имя_таблицы" WHERE условие;

|id| dog  | gender |
|--| ---- | ----   |
| 1| 'Max'| 'M'    |
| 2| 'Bob'| 'M'    |
| 3|'Luna'| 'F'    |

```
DELETE FROM dogs
WHERE gender='M';
```
Удалим из таблицы с собаками всех мальчиков.

- 4 -- ЗАПРОС/ПОЛУЧЕНИЕ ИЗ ТАБЛИЦЫ БД

**SELECT**

```
SELECT [DISTINCT | ALL]{*
 | [<выражение для столбца> [[AS] <псевдоним>]] [,…]}
FROM <имя таблицы> [[AS] <псевдоним>] [,…]
[WHERE <предикат>]
[[GROUP BY <список столбцов>]
[HAVING <условие на агрегатные значения>] ]
[ORDER BY <список столбцов>]
```

Пример 1: Показать всё что находится в магазине
```
SELECT *
FROM public."shop"
```

Пример 2: Выбрать всё товары с ценой 200
```
SELECT *
FROM public."shop"
WHERE price = 200;
```

- 5 -- ЗАМЕНА/ИЗМЕНЕНИЕ/ОБНОВЛЕНИЕ ДАННЫХ в ТАБЛИЦЕ БД

**UPDATE**

```
UPDATE <имя таблицы>
SET {<имя столбца> = {<выражение для вычисления значения столбца>
| NULL
| DEFAULT},...}
[ {WHERE <предикат>}]
```

Пример 1: Заменить в таблице все цены на 100
```
UPDATE shop 
SET price = 100;
```

Пример 2: Заменить цену у ботинок на 100
```
UPDATE shop 
SET price = 100 
WHERE id = 2;
```

ИСХОДНОЕ СОСТОЯНИЕ:

таблица = shop

|id| price| name     |
-- | ---- | -------- |
| 1|  700 | 'платье' |
| 2|  200 | 'ботинки'|
| 3|   10 | 'носки'  |
| 4| 1000 | 'штаны'  |
| 5|  200 | 'шарф'   |

Задача - У штанов повысить цену до 2000
```
UPDATE shop
SET price = 2000
WHERE id = 4
```
Итог

|id| price| name     |
-- | ---- | -------- |
| 1|  700 | 'платье' |
| 2|  200 | 'ботинки'|
| 3|   10 | 'носки'  |
| 4| 2000 | 'штаны'  |
| 5|  200 | 'шарф'   |

```
INSERT INTO shop (id, price) VALUE (6, 99)
```
таблица = shop

|id| price| name     |
-- | ---- | -------- |
| 1|  700 | 'платье' |
| 2|  200 | 'ботинки'|
| 3|   10 | 'носки'  |
| 4| 2000 | 'штаны'  |
| 5|  200 | 'шарф'   |
| 6|   99 |  NULL    |


Если какое-то значение для ячейки не указано в INSERT-е, то в ячейку вставтся, то, что указано после DEFAULT-та

НО ЕСЛИ таблица была создана с использанием вот такого Криейта (с DEFAULT значением):
```
CREATE TABLE "shop" (id INT primary key, price INT, name text DEFAULT 'товар');
```
ТО в результате такого INSERT-а
```
INSERT INTO shop (id, price) VALUE (6, 99)
```
БУДЕТ:

таблица=shop

|id| price| name     |
-- | ---- | -------- |
| 1|  700 | 'платье' |
| 2|  200 | 'ботинки'|
| 3|   10 | 'носки'  |
| 4| 2000 | 'штаны'  |
| 5|  200 | 'шарф'   |
| 6|   99 | 'товар'  |


А ЕСЛИ таблица была создана с использанием вот такого Криейта (с NOT NULL значением):
```
CREATE TABLE "shop" ( id INT primary key, price INT, name text NOT NULL);
```
ТО в результате такого INSERT-а
```
INSERT INTO shop (id, price) VALUE (6, 99)
```
БУДЕТ
 Сообщение: ERROR !!! name column must be NOT NULL !!!


- 6 -- УДАЛЕНИЕ ТАБЛИЦЫ БД

-- **DROP** TABLE "имя_таблицы";

```
DROP TABLE "shop";
```

# https://tproger.ru/articles/sql-interview-questions/

# ТИПИЧНЫЙ Вопрос с селектом:
Select *
FROM A , B

# ТИПИЧНЫЙ Вопрос:
Обычный JOIN это какой JOIN
Ответ = INNER JOIN

# ТИПИЧНЫЙ Вопрос:
Написать SQL – запрос для отображения текущей даты.
Ответ: SQL имеет встроенную функцию под названием GetDate(), которая возвращает текущую временную метку. Это будет работать в Microsoft SQL Server, другие производители, такие как Oracle и MySQL также имеет эквивалентные функции.
SELECT GetDate();

# 1ая,2ая,3я,4ая,5ая,6-тая НОРМАЛЬНЫЕ ФОРМЫ БД
НОРМАЛЬНЯ ФОРМА / НОРМАЛИЗАЦИЯ БД - требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

ССЫЛКА тут: https://habr.com/ru/post/254773/

# 1-ая НОРМАЛЬНАЯ ФОРМА:
- https://info-comp.ru/database-normalization

СУТЬ: В таблице в каждой ячейке должна всегда быть ОДНА сущность, не доуспкается перечислений.

ПЛОХАЯ БД:

|Фирма 	|Модели     |
 ------ | ----------
|BMW 	|M5, X5M, M1|
|Nissan |	GT-R|

МИНУС: Для моделей BMW, в одной ячейке содержится список из 3 элементов: M5, X5M, M1. 1 запись = 1 сущность, а тут в 1 ячейке их три

Преобразуем таблицу к 1НФ:

|Фирма 	|Модели|
------- | ------
|BMW 	|M5    |
|BMW 	|X5M   |
|BMW 	|M1    |
|Nissan |GT-R  |

# 2-ая НОРМАЛЬНАЯ ФОРМА
https://info-comp.ru/second-normal-form

СУТЬ: Выполняется 1НФ и дополнительно В таблице между значениями таблиц нет прямой повторяющейся однозначной зависимости, если таковые есть, то их стоит вывести в отдельную таблицу.

ПЛОХАЯ БД:

Модель|	Фирма |	Цена   | Скидка    |
----- |  ---- |  ----- | ----------|
M5    | BMW   | 5500000| 5%        | 
X5M   | BMW   | 6000000| 5%        |
M1    | BMW   |	2500000| 5%        |
GT-R  | Nissan| 5000000| 10%       |


МИНУСЫ: 1. Есть прямая повторяющаяся зависимость в рамках одной таблицы Фирма БМВ даёт скидку 5% , фирма Ниссан даёт 10% скидку
2. Если скидка у МБВ изменится на 7%, то в такой БД придётся в каждой ячейке менять с 5% на 7%. А если человек где-то ошибётся и оставит в таблице и 5% и 7% .... короче сплошные накладки.

Преобразуем таблицу к 2НФ разбив исходную на 2 Таблицы:

Модель|	Фирма |	Цена   |
----- |  ---- |  ----- |
M5    | BMW   | 5500000| 
X5M   | BMW   | 6000000|
M1    | BMW   |	2500000|
GT-R  | Nissan| 5000000|

Фирма |	Скидка    |
 ---- | ----------|
BMW   | 5%        | 
Nissan| 10%       |

Теперь изменнеие скидки достаточно поменять в одной таблице в одном месте

# 3-ТЬЯ НОРМАЛЬНАЯ ФОРМА
https://info-comp.ru/third-normal-form


СУТЬ: Выполняется 2НФ и дополнительно если В таблице одни столбцы являющиеся не ключевыми для каких-то столбцов и при этом связанны с другими неключевыми столбцами, то их нужно выносить в отдельные таблицы.

ПЛОХАЯ БД:

Модель|	Магазин    | Телефон  |
----- |  --------- |  ------- |
BMW   |	Риал-авто  | 87-33-98 |
Audi  |	Риал-авто  | 87-33-98 |
Nissan|	Некст-Авто | 94-54-12 |

МИНУСЫ: Таблица находится во 2НФ, но не в 3НФ.

В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина.

Таким образом, в отношении существуют следующие функциональные зависимости: Модель → Магазин, Магазин → Телефон, Модель → Телефон.

Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.

В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:

Магазин    | Телефон  |
---------- |  ------- |
Риал-авто  | 87-33-98 |
Некст-Авто | 94-54-12 |

Модель|	Магазин    |
----- |  --------- |
BMW   |	Риал-авто  |
Audi  |	Риал-авто  |
Nissan|	Некст-Авто |


# В Жизни достаточно знать 1+2+3 НФ

# 4/5/6-ТАЯ НОРМАЛЬНАЯ ФОРМА

- 4НФ - Когда все нетривиальные многозначные зависимости являются функциональными зависимостями от её потенциальных ключец.
```
Приведу лучше ПЛОХОЙ пример, не удоалветворяющий 4НФ:
{Ресторан} → {Вид пиццы}
{Ресторан} → {Район доставки}
```
То есть, например, при добавлении нового вида пиццы придется внести по одному новому кортежу для каждого района доставки. Возможна логическая аномалия, при которой определенному виду пиццы будут соответствовать лишь некоторые районы доставки из обслуживаемых рестораном районов.

- 5НФ - Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами.
Если «Атрибут_1» зависит от «Атрибута_2», а «Атрибут_2» в свою очередь зависит от «Атрибута_3», а «Атрибут_3» зависит от «Атрибута_1», то все три атрибута обязательно входят в один кортеж.

- 6НФ - Как по мне существует только в ТЕОРИИ .... Звучит так: Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6НФ, также находится и в 5НФ.

https://andreyex.ru/bazy-dannyx/uchebnoe-posobie-po-sql/14-naibolee-chasto-ispolzuemyx-zaprosov-sql-vopros-otvet/

https://habr.com/ru/post/181033/



https://ppt-online.org/146233




### English 
```
new [нью] - новый
old [олд] - старый
size [сайз] - размер
next [некст] - следующий / Далее
back [бэк] - назад / спина
previous [привэос] - предыдущий
data [дэйта] - данные
add [эд] - добавить
delete [делит] - удалить
step [стэп] - шаг
open [оупэн] - открыть
close [клоуз] - закрыть
save [сейв] - сохранить
load [лоад] - загрузить
option [опшн] - настройка, опция, вариант
propertie [проперти] - свойство
download [даунлоад] - скачать
upload [аплоад] - загрузить

who ? [ху] - кто
what ? [уот] - что
when ? [уэн] - когда
why ? [уай] - почему
how ? [хау] - как
whom ? [хум] - кому
about [эбаут] - о (чём-то / ком-то)

and [энд] - и
bool [бул] - булева
break [брэйк] - разбить
case [кейс] - случай
catch [кеч] - поймать / ловить
character [чарактэр] - символ, персонаж
cast [каст] - перевести (выполнить перевод из одного сост. в другое)
continue [континью] - продолжить
default [дефолт] - стандартный / по умолчанию
delete [делит] - удалить
do [ду] - делать
double [дабл] - двойной / удвоенный
dynamic [дайнэмик] - динамический
else [элс] - иначе
export [экспорт] - экспортировать
extern [экстерн] - внешний
false [фолс] - ЛОЖЬ
float [флоат] - плавающий (для цифр с плавающей точкой)
for [фор] - для
go to [гоу ту] - идити в
if [иф] - если
integer [интеджер] - целое (всмысле не дробное, про число)
name [нейм] - имя
space [спейс] - пробел, пространство
new [нью] - новый
pointer [поинтер] - указатель
private [прайвет] - приватный
protected [протектед] - защищённый
public [паблик] - публичный
return [ретёрн] - вернуть
short [шорт] - короткий
sign [сайн] - знак
signed [сайнт] - знаковый
size of [сайз оф] - размер (чего-то)
structure [страчер] - структура
switch [свич] - переключиться
template [темплейт] - шаблон
this [Зис] - это
thread [тред] - поток
local [локал] - локал
throw [фроу] - бросать
true [тру] - ИСТИНА
try [трай] - попытаться
type [тайп] - тип
union [юнион] - объединение
unsigned [ансайнт] - беззнаковый
use [юз] - использовать
using [юзинг] - используя
while [уайл] - во то время как

function [фанкшн] - функция
jump [джамп] - прыгать
big [биг] - большой
small [смол] - маленький
little [литл] - маленький
edit [эдит] - менять
deny [денай] - отменить
enable [энейбл] - задействовать
deprecated [деприкэйтед] - устаревший
call [кол] - вызвать, вызов
substract [сабстракт] - отнять / уменьшить
multiply [мультиплай] - умножить
erase [ирэйз] - стереть = удалить

add [эд] - добавить
insert [инсерт] - вставить
select [селект] - выбирать
new [нью] - создать

complete [комплит] - закончить / завершить / готов
incomplete [инкомплит] - незаконченный / незавершенный / неготов
different [дифферент] - другой / иной
difference [дифференс] - разница
algorythm [элгоритм] - алгоритм
compare [кмпэар] - сравнивать
read [рид] - читать
write [райт] - писать
access [эксэс] - доступ
word [ворд] - слово
last [лэст] - последний
first [фёрст] - первый
begin [бегин] - начало / начинать
end [энд] - конец / заканчивать
create [криэйт] - создавать
destroy [дестрой] - уничтожать
total [тотал] - полный / полностью
location [локэйшн] - место / позиция
recent[рисэнт] - текущий / настоящий
print [принт] - печатать
all [ол] - все
both [боуф] - оба
side [сайд] - сторона
letter [лэттэр] - письмо
preview [привью] - предпросмотр
attach [эттач] - вложение
share [шэр] - менять / обменивать / показывать / делиться
save [сэйв] - сохранять
load [лоад] - загружать
change [чейндж] - изменять
support [сапорт] - поддерживать
tool [тул] - инструмент
Check [чек] - проверять
Paste [пэйст] - Вставить
Cut [кат] - Вырезать
Font [фонт] - Шрифт
Color [колор] - Цвет 
Show [шоу] - показывать
Increase [инкриз] - увеличивать
Decrease [дериз] - уменьшать
Change [чейндж] - изменять
Find [файнд] - найти
Replace [реплэйс] - заменять / менять местами
Select [селект] - выбирать
Shape [шэйп] - форма
Blank [блэнк] - Пустая
Link [линк] - Ссылка
Header [хэдэр] - заголовок
Equation [экуэйжн] - выражение

Margin [маргин] - Поле
Page [пэйдж] - Страница
Line [лайн] - строка
Column [колам] - столбец
Column [колам] - Колонка
Even [ивэн] - Четная
Odd [од] - Нечетная
Left [лэфт] - Слева
Right [рфйт] - Справа
Before [бефор] - До
After [афтэр] - После 
Position [позишн] - Положение
Bring [бринг] - принести
Forward [форворд] - вперед
Backward [бэкворд] - назад 
Send [сэнд] - отправить 
Pane [пээн] - Область
Align [элайн] - Выровнять
Rotate [ротэйт] - Повернуть
angle [энгл] - угол
Mark [марк] - Пометить
Entry [энтри] - элемент
Note [ноут] - Показать сноски
Style [стайл] - Стиль
List [лист] - список
Rule [рул] - Правила
Field [фиилд] -  поле
Merge [мёрдж] - объединить
Split [сплит] - Разделить 

help [хэлп] - помогите, помогать, помощь
tab [тэб] - вкладка
home [хоум] - дом
push [пуш] - нажать, давить
page [пэйдж] - страница
reference [референс] - ссылка
mail [мэйл] - почта
view [вью] - вид, представление
review [ревью] - обзор
title [тайтл] - надпись
point [поинт] - точка
button [баттон] - кнопка
box [бокс] - коробка
scroll [скрол] - Ползунок
scroll box [скрол бокс] - Ползунок прокрутки
zoom [зум] - прибилжать
send [сэнд] - отправлять
recieve [ресив] - получать
layout [лэйаут] - разметка / схема / макет
label [лэйбл] - надпись
save [сэйв] - сохранить
save as [сэйв эз] - сохранить как
open [оупен] - открыть
close [клоуз] - закрыть
info [инфо] - сведения
recent [рисэнт] - последние
print [принт] - печать
options [опшн] - параметры
exit [экзит] - Выход

Window [уиндоу] - окно
Comment [коммент] - Примечание, Комментарии
Change [чейндж] - изменять
Accept [эксэпт] - принимать
Protect [протэкт] - защищать
Block [блок] - блокировать
Restrict [рестрикт] - запрещать / оагрничивать
Record [рекорд] - записывать
Security [секьюрити] - безопасность
Drop [дроп] - бросать
Pick [пик] - выбирать
Frame [фрэйм] - рамка 
Reset [рисэт] - перезагружать / перезапускать
Image [имэйдж] - изображение
Mode [моуд] - Режим 
Group [груп] - Группи
Schema [шэма] - Схема
Template [тэмплейт] - Шаблоны
Border [бордэр] - Границы
Pen [пэн] - перо
Style [стайл] - Стиль 
Weight [вэйт] - Толщина 
Height [хэйт] - Высота 
Widht [уидт] - Ширина 
Draw [дроу] - рисовать
Table [тэйбл] - Нарисовать таблицуэ
Eraser [эрэйзр] - Ластик
Fit [фит] - Автоподбор
Align [элайн] - Выровнять 
Repeat [рипит] - Повторить 
Convert [ковёрт] - Преобразовать 
Adjust [эджаст] - применять
Background [бэкграунд] - фон
Compress [компрэс] - сжимать
Wrap [урэп] - сворачивать / обёртка
Arrange [эррэйндж] - выстраивать / подстроить

Layout [лэйаут] - Макет 
Crop [кроп] - Обрезка

Forward [форвуард] - вперёд
Backward [бэквуард] - фон
Fill [фил] - заполнить
Outline [аутлайн] - контур
Direction [дайрекшн] - напрвление
Shape [шэйп] - Фигуры
Picture [пикчэр] - Рисунок
Axe [экс] - Ось / Оси (Икс / Игрек / Зэд)
Wall [уол] - Стенка
Area [эриа] - Область
Background [бэкграунд] - Фон
Up [ап] - над / наверх / наверху
Down [даун] - вниз / внизу
under [андэр] - под
over [оувэр] - над
Error [эррор] - ошибка
exception [эксэпшн] - исключение

point [поинт] - точка
line [лайн] - линия
polyline [полилайн] - многоугольная линия / ломаная
ellipse [эллипс] - элипс
circle [сиркл] - круг
rectangle [рэктэнгл] - прямоугольник
square [скуэар] - квадрат
triangle [трайэнгл] - треугольник
angle [энгл] - кгол
side [сайд] - сторона
polygon [полигон] - многоугольник

select [селект] - выбирать
insert [инсерт] - вставлять
update [апдейт] - обновлять
delete [делит] - удалять

include [инклуд] - вставлять
import [импорт] - подключать
return [ретёрн] - возвращать

memory [мэмори] - память
drive [драйв] - водить авто
sound [саунд] - звук
unique [юник] -  уникальный
description [дескрипшн] - описание
display [дисплэй] - отображать
launch [лаунч] - запускать
crash [скэр] - крах / авария / аварийное завершение
fall [фол] - падение
settings [сэттингз] - настройки
amount [эмаунт] - количество
must [маст] - должен
disable [дисэйбл] - отключать
prefear [прифэар] - предпочитать
count [каунт] - считать / пересчитывать / количество
engine [энджин] - двигатель / средство / инструмент
core [кор] - ядро
current [каррэнт] - текущий / данный
device [девайс] - устройство
brows [брауз] - одалживать
advanced [эдвансд] - дополнительно
direct [дайрект] - непосредственно / прямо / точно
custom [кастом] - определённая
сompatibillity [компатибилити] - совместимость
show [шоу] - показывать
with [уизтх] - с
specify [специфити] - указывать / уточнять
present [презент] - настоящий / имеющийся в наличии
allow [эллау] - допускать / дозволять
any [эни] - любой / каждый
```

