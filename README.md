# TestingLectures
Lestures for testing courses

# MD Format
https://github.com/tchapi/markdown-cheatsheet/blob/master/README.md

# FAQ - Часто задаваеме вопросы
Вот пара ссылок на карты знаний для тестировщиков, но можете на просторах найти и другие. 

https://www.mindmeister.com/ru/1324282825/junior-qa?fullscreen=1 

https://www.mindmeister.com/ru/1558647509?t=973hdS2AKb 

Некоторые компании подробно расписывают на своих порталах ожидания от каждой стадии развития сотрудника, тоже не проблема найти, по этой же теме много видео на Youtube (раз, два, три, четыре, …). Если попытаться выделить самые частые вопросы на собеседованиях, то получится примерно следующее:

- Что такое тестирование?
- Зачем оно нужно?
- QA/QC/Тестирование - разница?
- Что такое качество ПО?
- Верификация и валидация?
- Severity priority?
- Виды, типы, уровни тестирования?
- Виды документации? Тест-план, тест-кейс, чек-лист?
- Что такое баг? Его жизненный цикл?
- Техники тест-дизайна?
- SDLC, STLC; Методологии разработки ПО?
- Мобильное тестирование: его особенности (и в частности жизненный цикл Android и iOS приложения)?
- Клиент-серверная архитектура?
- API?
- Базовое знание сетей: HTTP(S), его методы, коды ответов, Query-параметры, REST/SOAP, JSON/XML
- Базы данных: что такое SQL, СУБД, основные команды (особенно любят джойны).
- Инструменты: Chrome DevTools, Postman, Charles/Fiddler, GIT, TMS
- Практика: тестирование форм или какого либо сайта, приложения  (в частности  составление тест-кейсов и баг-репортов), придумать хороший summary для репорта, определение severity/priority; SQL запросы; что-нибудь на "подумать".

В случае gamedev могут еще спросить про последнее во что играл, что понравилось/не понравилось и т.п.

Помимо вышеперечисленного нужно помнить об английском языке и его важности в работе.

# Основные инструменты тестировщика?

- Мультитул: DevTools;
- Снифферы: WireShark, Charles Proxy, Fiddler;
- Тестирование API: Postman, SoapUI;
- Тестирование производительности: JMeter;
- Тестирование безопасности: Kali linux,  Santoku Linux + drozer, OWASP ZAP, …;
- Тестирование UI/UX: Figma, Zeplin, любой mindmap-like продукт;
- Фермы устройств для тестирования мобильных приложений: BrowserStack, Xamarin, AWS;
- Инструменты тестирования Android приложений
- Системы контроля версий: GIT;
- Взаимодействие с базами данных: язык SQL, системы СУБД;
- Системы CI/CD: Jenkins/TeamCity;
- Прочее: мессенджеры, баг-трекинговые системы и TMS, генераторы тестовых данных и т.п.
- Виртуалки = Виртуальные машины для тестирования десктоп приложений и не только

DevTools: В каждый современный браузер встроены инструменты разработчика — они позволяют быстро отловить и исправить ошибки в разметке или в коде. С их помощью можно узнать, как построилось DOM-дерево, какие теги и атрибуты есть на странице, почему не подгрузились шрифты и многое другое:

# Что означает тестирование ПО?
Тестирование (testing) программного обеспечения  - с технической точки зрения заключается в выполнении приложения (Application Under Testing (AUT) или Implementation Under Testing (IUT)) на некотором множестве исходных данных и сверке получаемых результатов с заранее известными (эталонными) с целью установить соответствие различных свойств и характеристик приложения заказанным свойствам. Как одна из основных фаз процесса разработки программного продукта (Дизайн приложения - Разработка кода - Тестирование ), тестирование характеризуется достаточно большим вкладом в суммарную трудоемкость разработки продукта. Широко известна оценка распределения трудоемкости между фазами создания программного продукта: 40%-20%-40%, из чего следует, что наибольший эффект в снижении трудоемкости может быть получен прежде всего на фазах Design и Testing. В более широком смысле, тестирование ПО - это техника контроля качества программного продукта, включающая в себя проектирование тестов, выполнение тестирования и анализ полученных результатов. 

# Почему требуется тестирование ПО?
- Процесс тестирования гарантирует, что ПО будет работать в соответствии с ожиданиями клиентов и на имеющемся у них оборудовании.
- Это уменьшает циклы кодирования, выявляя проблемы на начальном этапе разработки. Обнаружение проблем на более ранних этапах SDLC обеспечивает правильное использование ресурсов и предотвращает повышение стоимости.
- Команда тестирования привносит взгляд клиента в процесс и находит варианты использования, о которых разработчик может не подумать.
- Любой сбой, дефект или ошибка, обнаруженные клиентом в готовом продукте, нарушают доверие к компании.

# Что означает обеспечение качества (Quality Assurance - QA) при тестировании ПО?
Это совокупность мероприятий, охватывающих все технологические этапы разработки, выпуска и эксплуатации ПО и информационных систем, предпринимаемых на разных стадиях жизненного цикла ПО, для обеспечения требуемого уровня качества выпускаемого продукта. Доп. материал: QA — специалист по пожарной безопасности вашего проекта

# Разница между верификацией и валидацией? (Verification и Validation)

### Верификация — это процесс включающий в себя проверку Plans, Requirement Specifications, Design Specifications, Code, Test Cases, Check-Lists, etc.
- Верификация всегда проходит без запуска кода.
- Верификация использует методы — reviews, walkthroughs, inspections, etc.
- Верификация отвечает на вопрос "Делаем ли мы продукт правильно?"
- Верификация поможет определить, является ли программное обеспечение высокого качества, но оно не гарантирует, что система полезна. Проверка связана с тем, что система хорошо спроектирована и безошибочна.
- Верификация происходит до Validation.

### Валидация (validation) – это процесс оценки конечного продукта, необходимо проверить, соответствует ли программное обеспечение ожиданиям и требованиям клиента. Это динамический механизм проверки и тестирования фактического продукта.

- Валидация всегда включает в себя запуск кода программы.
- Валидация использует методы, такие как тестирование Black Box, тестирование White Box и нефункциональное тестирование.
- Валидация отвечает на вопрос "Делаем ли мы правильный продукт?"
- Валидация проверяет, соответствует ли программное обеспечение требованиям и ожиданиям клиента.
- Валидация может найти ошибки, которые процесс Verification не может поймать.
- Валидация происходит после Verification.


# * Что подразумевается под тестовым покрытием? (Test Coverage)
Тестовое Покрытие - это одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода. Сложность современного ПО и инфраструктуры сделало невыполнимой задачу проведения тестирования со 100% тестовым покрытием. Поэтому для разработки набора тестов, обеспечивающего более-менее высокий уровень покрытия можно использовать специальные инструменты либо техники тест дизайна. Существуют следующие подходы к оценке и измерению тестового покрытия:

- Покрытие требований (Requirements Coverage) - оценка покрытия тестами функциональных и нефункциональных требований к продукту путем построения матриц трассировки (traceability matrix).
- Покрытие кода (Code Coverage) - оценка покрытия исполняемого кода тестами, путем отслеживания непроверенных в процессе тестирования частей ПО.
- Тестовое покрытие на базе анализа потока управления - это одна из техник тестирования белого ящика, основанная на определении путей выполнения кода программного модуля и создания выполняемых тест кейсов для покрытия этих путей. 

# Что такое аудит качества? 
Аудит качества - это процесс систематической и независимой проверки программного продукта или процесса для оценки соответствия спецификациям, стандартам, соглашениям и другим соответствующим критериям. 

# Почему невозможно полностью протестировать ПО? 
- Спецификации ПО могут быть субъективными и приводить к различным интерпретациям. 
- ПО может потребоваться слишком много входов, слишком много выходов и слишком много комбинаций путей для тестирования.

# Как вы тестируете продукт, если требования еще не зафиксированы? 
Если спецификация требований недоступна для продукта, тогда план тестирования может быть создан на основе предположений, сделанных относительно продукта. Но мы должны хорошо документировать все предположения в плане тестирования. 

# Как вы узнаете, было ли создано достаточно тестов для тестирования продукта? 
Прежде всего, мы проверим, охватывает ли каждое требование хотя бы один Test case. Если да, то можно сказать, что тестовых примеров достаточно для тестирования продукта.  

# * Тестовые данные / Что такое тестовые данные / Что подразумевается под тестовыми данными?
Тестовые данные - это набор входных значений, необходимых для выполнения Test case. тестировщики определяют данные в соответствии с требованиями. Они могут сделать это вручную или использовать инструменты генерации.  

# * Основные фазы тестирования?

- Pre-Alpha: - ПО является прототипом. Пользовательский интерфейс завершен. Но не все функции завершены. На данном этапе ПО не публикуется. 
- Alpha: является ранней версией программного продукта. Цель - вовлечь клиента в процесс разработки. Хороший Альфа-тест должен иметь четко определенный план тестирования с комплексными тестовыми примерами. Это дает лучшее представление о надежности программного обеспечения на ранних стадиях. В некоторых случаях тестирование может быть передано на аутсорс. 
- Beta: ПО стабильно и выпускается для ограниченной пользовательской базы. Цель состоит в том, чтобы получить отзывы клиентов о продукте и внести соответствующие изменения в ПО. 
- Release Candidate (RC): основываясь на отзывах Beta Test, вы вносите изменения в ПО и хотите проверить исправления ошибок. На этом этапе вы не хотите вносить радикальные изменения в функциональность, а просто проверяете наличие ошибок. RC также выпущен для общественности 
- Release: Все работает, ПО выпущено для общественности. 

# В чем отличие build от release?
Билд это номер, даваемый ПО при передаче от разработчиков тестировщикам. Релиз — это номер, даваемый ПО при передаче конечному пользователю. 

# Что такое бизнес – логика (domain)?
Бизнес – логика (domain) это то, что конкретная программа по задумке должна сделать. Например, в складской программе проверка на возможность отправить товар (вдруг его нет в наличии). Это правила, которые должны соблюдаться в данной конкретной программе, определенные бизнес-клиентом. Слои приложения – слой пользовательского интерфейса, слой бизнес логики, слой сохранения данных. 

# ----- Виды тестирования -----
# ТИПЫ ТЕСТИРОВАНИЯ / ВИДЫ ТЕСТИРОВАНИЯ:


- Positive - Позитивное тестирование (+)
- Negative - Негативное тестирование (-)

- Функциональные виды («Что?» - проверяет весь функционал продукта):
  - Функциональное тестирование (-)(+) (Functional testing)
  - Тестирование взаимодействия (-)(+) (Interoperability testing)
	
- Нефункциональное («Как?»):
  - Производительности / Тестирование на производительноcть (-)(+) (Performance)
    - Тестирование емкости/способностей (-)(+) (Capacity testing)
    - Стрессовое (-) (Stress testing)
    - Нагрузочное (-)(+) (Load testing)
    - Объемное тестирование (Volume testing)
    - Выносливости (-)(+) (Soak/Endurance testing)
    - Стабильности/надежности (-)(+) (Stability / Reliability testing)
    - Шиповое (Spike)
    - Отказоустойчивости (-)(+) (Stability testing)
    - Масштабируемости (Scalability test)
		
  - Отказ и восстановление (-) (Failover and Recovery testing)
  - Удобство пользования (Usability testing) - Удобство использования тестируемого объекта -  Use –использовать  Ability – возможность 
  - Тестирование установки (-)(+) (Installation testing)
  - Тестирование безопасности (Security and Access Control testing) - тестирование возможно только, если что-то можно украсть
  - Конфигурационное (Configuration testing)
	
Связанное с изменениями:
  - Регрессионное (Regression testing) - Проверка на то, не роняет ли разработанная сейчас фича, то, что уже работало ранее. (в уже оттестированное ПО добавили фичу, надо проверить не поломала ли новая фича работоспособность старых фич, уже отлаженных и корректно работающих)
  - Тестирование на совместимость – совместимость программного обеспечения или приложений проверяется с различными платформами, средами, операционными системами, версиями, мобильными устройствами и т. Д.
  - Санитарное (Sanity testing)
  - Дымовое / Дымное (Smoke testing) – проверка на то, включится ли то, что тестируем и не загорится ли сразу (тест старта системы / кнопки ВКЛ)
  - Тестирование сборки (Build Verification testing)

Прочие:
- Тестирование методом Чёрного Ящика (-)(+) – Тестирование системы, без знания того как устроена тестируемая система досканально изнутри. Есть только спецификация / общее описание / инструкция в которой описано текстом как работает система (Применительно к ПО - код программы мы не видим - потому ящик и чёрный).
- Тестирование методом Белого Ящика (-)(+) – Тестирование системы с доступом до всех внутренностей, как разработчик системы (Ящик по факту Прозначный = "Белый" - мы не только имеем на руках спецификацию / общее описание / инструкцию, мы имеем доступ к коду ПО, можем его запускать и отлаживать. В случае если мы тестируем аппаратуру, мы имеем доступ ко всем микросхемам/платам имеем доступ такой же как и разработчик системы)
- Компонентное / Модульное / Блочное / Поблоковое тестирование (-)(+) (Unit Testing) - Тестирование отдельного модуля, без привязки к целостной системе ПО. Цель модульного тестирования — изолировать отдельные части программы и показать, что по отдельности эти части работоспособны. Этот тип тестирования обычно выполняется программистами.
- Интеграционное тестирование - ПО состоит из нескольких модулей (они тестируются все вместе, как группа), проверяем корректность работы этих модулей друг с другом + обмена данными между ними. (1) Как новая хотелка от заказчика встроится в существующую инфраструктуру (ПО)  (2) Тестирование того, как новая фича въедет в уже существующее ПО (3) Тестирование модуля при взаимодействии с другими уже существующими модулями, чтобы проверить на сколько он в состоянии функционировать с другими частями и модулями ПО, не ломая работу других. (набор готовых, работающих друг с другом программ / модулей. И надо в их уже налаженную работу встроить ещё один уникальный новый модуль)

- Ручное тестирование (-)(+) – тестирование руками живого человека-тестировщика, а так же его глазами и мозгом, который способен среагировать на непредвиденное поведение системы и выполнить соотвествующие действия, его труд в процессе анализа возможно удастся автоматизировать
- Автоматическое тестирование (-)(+) – тестирование системой автотестирования / скрипты и прочее. Наборы тестов, которые написаны заранее и идущие в строгом порядке и проверяющие всё значительно быстрее чем ручной тестер
- Тест на соответствие документации (+) – Идём по документации и проводим тесты по тому, что в ней написано
- Тестирование Графического интерфейса (-)(+) – Тестирование на то на сколько корректно работает Графический интерфейс со всех точек зрения (функциональной / соотвествие бизнеслогики из спеки / юзер)
- Тестирование на работу с входными данными (- некорректные)(+корректные) –

- Валидация
- Верификация
- Бета тестирование - тестирование первого работающего прототипа полной версии программы с почти всем готовым функционалом
- Приёмочное теситрование - Проверка конечной работы продукта перед передачей заказчику. Перед передачей заказчику проверяется, чтобы заказчику был передан код программы, и чтобы заказчик мог бы собрать проект у себя.



- Тестирование на совместимость версий – 
```
Клиент (ver 1.0)  Сервер (ver 1.0) - было
Клиент (ver 2.0)  Сервер (ver 1.0) – стало
Вопрос, совместима ли версия клиента 2.0 с версией Сервера 1.0
Программа (ver 1.0)  конфигурационный файл (ver 1.0) - было
Программа (ver 2.0)  конфигурационный файл (ver 1.0) – стало
Вопрос, совместима ли версия Программы 2.0 с версией конфиг.файла 1.0
```


ТЕСТИРОВАНИЕ СОФТА:

ТЕСТИРОВАНИЕ СОФТА:

### ТЕОРИЯ ТЕСТИРОВАНИЯ - С ЧЕМ РАБОТАЕТ ТЕСТИРОВЩИК

План тестирования -  Очень общо описываются что тестируем, цели тестирования, общие положения. Описание методики тестирования продукта, на основании существующих к нему Требований (как должны работать те или иные части программы). То есть набор тест-кейсов, в неформализированном виде.

- **Сценарий тестирования** - (ТЕСТ КЕЙС /тестовый случай) ПРИСЛАТЬ ПРИМЕР
Их надо брать и описывать в Жире. И проходить по ним потом много раз. Их так же удобно потом передавать программисту или эксплуатации, чтобы они могли проверить работу той или иной части программы, к котрой написан тест-кейс. По сути, упрощенное описание теста. Входная информация, условий и последовательности выполнения действий и ожидаемого выходного результата. 
- **Тестовые Входные данные** - Наборы входных данных для тестов, а также ожидаемые результаты, с которыми полученные результаты выполнения тестов должны сравниваться как с эталонными.  Рекомендуется собирать вместе данные для каждой определенной группы тестов 
- **Тестовый скрипт** - Обычно говорят о программной реализации теста, хотя скрипт может описывать и ручные действия, необходимые для выполнения конкретного тест кейса. 
- **Набор тестов** - Как правило, сценарии тестирования объединяются в пакеты или наборы. Для группирования тестов со сходными задачами, или если надо менять порядок в группе тестов, поэтому их удобно хранить наборами.
- **Результаты тестирования** - Представляют собой суммарную информацию о прохождении тестов, Записываются и сохраняются для каждого этапа тестирования. 
(Тест-кейсы в табличке с плюсиками и минусиками.)
- **Дефекты, Ошибки, Баги, Исключения**  - обнаруженные факты несоответствия системы предъявляемым требованиям. Порой их выписывают, делается градация, и типизпция Дефектов, чтобы в будущем понимать к какому виду отнёсся найденный дефект и оценка степени его критичности.
	



Любому тестировщику нужно 3 вещи:
- Ознакомиться с системой - в последствии знать систему и как она работает сейчас
- как должен работать какой-то новый функционал, чтобы понимать как его тестировать - СТАНДАРТНЫЕ СЦЕНАРИИ - то как ДОЛЖНО работать
- задаваться постоянно вопросом "ЧТО ЕСЛИ" и тестировать НЕСТАНДАРТНЫЕ СЦЕНАРИИ - то как МОЖЕТ работать, но не факт, что так ДОЛЖНО или вообще НЕ ДОЛЖНО

1. Ручное тестирование - примитивно, но тесты человеком порой необходимы даже самой хорошо запрограммированной системе, т.к. автот-тесты порой слишком "тупы", чтобы увидеть то, что может увидеть человек

2. Автотесты - Нужны только в тех случаях, когда чётко понятно, что тест или некая последовательность действий повторяется с минимальными изменениями.
Итеративный подход тестирования и архитектура на основе компонентов особенно подчеркивают целесообразность регрессионного тестирования качества продукта для каждого цикла компоновки. Все тесты, разработанные для версии X, являются потенциальными кандидатами для регрессионного тестирования версии X+1, X+2 и т.д. Когда тест повторяется несколько раз, возможно, его следует автоматизировать. Автоматизированное тестирование позволяет выполнять сценарии при повторном тестировании и переключать сотрудников на работу с тестированием новых функций

Для (Ручное тестирование / Автотресты) обоих важно ОДНО:

Важно соблюдать методологию тестирования

Чтобы ПО согласно Жизненному циклу разработки ПО шло строго по 5-ти пунктам:

1. Анализ требований
2. Проектирование
3. Разработка
4. Тестирование
5. Эксплуатация, Тех поддержка

**ПРИЧИНА И ПРИМЕР**: в жизни может произойти так: из 3-го этапа сразу в 5-тый.
Программист закодил фичу. Подумал, что закодил всё без ошибок.
Отдал заказчику, не стал из-за столь мелкой фичи беспокоить тестировщика.
Заказчик поставил прогу с Фичей, фича уронила ВСЁ приложение.

**Ручные тесты** - состоят из нескольких шагов, на каждом из которых тестер имеет возможность держать систему под контролем. Если мы зависли, ПО упало, мы увидели что-то на экране. Мы тут же можем пойти дальше и тестировать руками следуюший Кейс.
Т.Е. нам не обязательно 100% знать наперёд как работает тестируемый кусок ПО.

**Автотесты**  - стоят из последовательности шагов, на каждом из которых система может выйти из под контроля. Упасть, и тест не продолжится, зациклиться, зависнуть, и мы можем не понять это тест тупит или это ПО зависло. В этом случае, нам нужно будет переписывать и редактировать автотест, чтобы перейти к следующему Кейсу.
Т.Е. нам надо подробно знать или представлять на 99% как минимум как работает тестируемый кусок ПО, иначе автотест может не отработать никогда или мы будем править его 100 раз.

Автотесту нужно отдельно обрабатывать ситуацию и как-то мочь понимать, что ПО упало (он может сверится по Логам программы например), как правило автотест просто не способен отработать следующий после падения шаг. НО это далеко не факт. При ручном тестировании мы видим это сразу и нам не нужно дополнительно удостовериться в том, что программа работает некорректно.

**ПЛЮСЫ и МИНУСЫ Ручного тестирования и Автотестов**

Автотест не способен обработать НЕПРЕДВИДЕННЫЕ ситуации и шаги, которые в нём не описаны. Автотест никогда не поправит что-то докучи/заодно/заметил ещё. Ручное тестирование может обработать почти любое непредвиденное поведение программы, провести анализ и т.д. 

Ручное тестирование – человек может увидеть больше глазами и мозгом, и домыслить что-то более правильно, выявить неочевидное, поправит что-то докучи/заодно/что заметил ещё.

1. тестирование Фронт Энда
```
Как правило тестирование верно реализованной логики согласно:
  БТ – Бизрнес Требование
  ФТ – Функциональным требованиям
  ТЗ / ЧТЗ – (Частное) Техническое Задание
  Документация / Спецификация
 Важно соблюдать методологию тестирования
 Чтобы ПО согласно Жизненному циклу разработки ПО шло строго по 5-ти пунктам:
```  
2. тестирование Бэкэнда
```
 Через .bat-файлы. Скриптовые тесты. Тесты при помощи спец. программ.
 Бэкэнд это как правило СЕРВЕР. Для сервера проводится обычно НАГРУЗОЧНОЕ тестирование.
 Сколько сотен / тысяч / миллионов запросов в секунду и с какой интенсивностью сервер 
 способен держать запросов. Как быстро он под нагрузкой способен работать и не УПАСТЬ. 
 ОБЫЧНО Консольные приложения, а значит всё управляется командами строчками
```
**Тестовый Стенд** - Место / Среда / Виртуальная машина / Отдельный компьютер - на котором проводятся тесты. Это среда для тестирования Максмально приближенная к Среде в которой живёт и работает заказчик.
  
  ПРИМЕР: Заказчик работает на Windows 7, вся его компания и весь его парк машин в размере 200 ПК работает на 7-ке и ни на чём больше.  - Логично в качестве тестового стенда использовать виртуалку с 7-кой, и даже не тестить на Windows XP, MacOS или даже Win10. Ибо смысла мало.
  
  Другая ситуация, когда ПО кроссплатформенное, работать должно на разных версиях Винды, и не только на Винде - тогда тестовых стендов надо иметь несколько и тестироваться на многих тестовых стендах.



Бывают так же и наборы тестовых данных на которых ПО 100% падает.

```
Тест  - отчёт по каждому тесту - с описанием шагов внутри теста
Тест может пройти все шаги, и пройти успешно
Тест может свалиться на каком-то шаге и об этом надо 
```
```
Внутри Фреймворков для тестирования и автотестов
Есть уже какие-то определённые функции
Мы можем дополнять их и своими
Пользуемся функциями - и получаем ТЕСТ
ТЕСТ можно прогонять в Цикле несколько раз, с изменением каких-то параметров
```

ТЕСТИРОВАНИЕ User Interface.

SELENUIM (Web / Desctop), Bad Boy (Web / Desctop) - Через окно браузера: Веб драйвер имитирует действия человека.

1. Перешли на сайт
2. Найти кнопку с селектором, или каким-то названием
3. кликнуть на неё
4. вбить текст в эдит-бокс и т.д.

TEAM CITY - типа Дженкинс, но для Винды

CODE UI TEST - ТЕСТИРОВАНИЕ ВНУТРИ СТУДИИ
https://msdn.microsoft.com/en-us/library/dd286726.aspx


ТЗ по ГОСТ-у:
Как написать Техническое задание по ГОСТу | СЭД "Кодекс: документооборот" (kodeksdoc.ru)

ЧТО ДЕЛАЮТ ТЕСТИРОВЩИКИ В РЕАЛЬНОЙ ЖИЗНИ:
- пишут документы ТестКейсы, Тестпланы, ЧекЛисты (ТЗ и прочие документы, когда в компании не хватает рук или близится релиз, а тех.писатели не успевают с документами)
- продумывают тесты по ненаписанному ПО по ТЗ и пишут тесты по реализованному ПО
- тестеры тестируют ПО



### ТИПИЧНЫЕ ВОПРОСЫ ТЕСТИРОВЩИКУ:

КАК ВЫ БУДЕТЕ ТЕСТИРОВАТЬ:

- КАЛЬКУЛЯТОР
  - заставить его не работать
  - заставить его сломаться в рамках его функционала (вынуть батарейки это не сломать)
  - заставить его работать нестандартно, вызвать неопределённое поведение

в рамках известной корректной функциональности, заставить его сломаться или работать не так как ожидается.

- КАРАНДАШ, РУЧКА, КИРПИЧ
  - тестируется понимание функционального тестирования
  - тестируется понимание, что есть ГОСТы

- ОГНЕТУШИТЕЛЬ, ЛИФТ
  - как тестируется что-то что связанно с угрозой жизни человека

- МЕТЕОСТАНЦИЮ
  - тестируется умение фантазировать и придумывать нестандартные тесты для нестандартно описанной задачи
  - проявить изобретательность

Как тестировать Карандаш, тостер, банкомат, мост, аппарат проающий бутылки воды

https://www.youtube.com/watch?v=Erctsy6i0zo

# ТИПИЧНЫЕ ВОПРОСЫ ТЕСТИРОВЩИКУ:

Как тестировать Карандаш, тостер, банкомат, мост, аппарат продающий бутылки воды

https://www.youtube.com/watch?v=Erctsy6i0zo


1. Просим - есть ли СПЦИФИКАЦИЯ.
2. Уточнение 
2.1 всех внутренних свойств тестируемого объекта (исходное состояние того, что мы тестируем)
2.2 всех внешних условий среды, в которых предполагается выполнять сами тесты (среда тестирования)
3. Начинаем с позитивного тестирования. (Предмет теста выполняет те функции, к которым он был предназначен, для чего был изначально сделан)
4. Негативное тестирование потом, возможно.

// Закзик Внешний заказчик / Внутри

ТЕОРИЯ: Должна быть написана документация на основе требований от заказчика 
(Работы заказчика / бизнес-аналитика / менеджера в нашей компании, который работает с заказчиком и / аналитика на нашей стороне)

**ИДЕАЛ ТЕОРИИ / КАК ТЕОРИЯ ВИДИТ СЕБЯ НА ПРАКТИКЕ:**

**[1]** Заказчик говорит в общих чертах что нужно, составляет DOC-домунет в который вставляет  принтскрины из разных программ, которые ему нравятся, с функционалом примерно похожим на тот, что ему реально надо, и дописывает к этим принскринам 
свои комментарии, что доделать / поправить / изменить и т.д.
ИЛИ на софт такого типа (РЖМ/МЕДИЦИНА/ГОСОРГАНЫ/СТРОИТЕЛЬСТВО) есть ГОСТЫ, СНИПЫ, и прочее, и заказчик копирует описание из ГОСТОВ.

**[2]** Наш менеджер записывает заказчика на диктофон, чтобы запомнить все его котелки, допечатывает DOC-файл от заказчика поадекватнее, дописывает подробности, которые заказчик произнёс вслух, но не дописал в файл текстом. Проверил документ на здравый смысл и уточнил у заказчика, пункты, которые сделать физически невозможно или если написан полный бред, обсудил его, чтобы бред устранить на первом же этапе согласования. +оформляет документ по ГОСТУ, если он знает ГОСТ.
[ПО ГОСТУ – ПРИСЛАТЬ ДОК ОФОРМЛЕННЫЙ ПО ГОСТУ]

**[3]** Это всё попадает Аналитику - Аналитик в спец программе рисует интерфесы, убирая "принтскрины-примеры", описывает как общее:
структура приложения / основные функуиональные блоки

**[4]** Разработчки получает все документы и разрабатывает по ним ПО

**[5]** Тестировщие получает ПО от разработчика и тестирует ПО

**[6]** Заказчик получает разработанное и оттестированное ПО со всеми документами и прочей сопроводиловкой


**ПЛОХАЯ ПРАКТИКА 1**: Документация пишется от балды, но хоть какая-то черновая, дописывается по готовому и оттестированному Софту.

**ПЛОХАЯ ПРАКТИКА 2**: Документация пишется по уже написанному, готовому и оттестированному Софту, за 5 дней до передачи заказчику.



###  НЕМНОГО О СКПРИТАХ

Writing C++ Scripts
 Applies to TestComplete 12.31, last modified on July 10, 2017
C++Script is a specific dialect of the C++ programming language supported by TestComplete. It is based on JScript. It was specially designed to let C++ developers easily port script routines to their C++ Self-Testing and Connected Applications.
TestComplete can both record and play back C++Script routines. That is, you can record a script in TestComplete, debug it there, then import this script to your C++ application and make it work by adding just a few lines. For instance:
// This code was recorded by TestComplete:
```
function Test()
{
  var p, w;
  p = Sys["Process"]("notepad");
  w = p["Window"]("Notepad", "*");
  w["Activate"]();
  w["Window"]("Edit")["VScroll"]["Pos"] = 0;
  w["Window"]("Edit")["Click"](9, 9);
  Sys["Keys"]("Test");
  w["MainMenu"]["Click"]("File|Exit");
}	// This code was imported to a C++ Connected Application:
 
#include "c:\TestComplete\Connected Apps\C++\script.h"
using namespace TestComplete;
IMPLEMENT_TESTCOMPLETE_GLOBAL_OBJECTS
```

```
function Test()
{
  var p, w;
  p = Sys["Process"]("notepad");
  w = p["Window"]("Notepad", "*");
  w["Activate"]();
  w["Window"]("Edit")["VScroll"]["Pos"] = 0;
  w["Window"]("Edit")["Click"](9, 9);
  Sys["Keys"]("Test");
  w["MainMenu"]["Click"]("File|Exit");
}
The language of the code recorded by TestComplete for your C++ projects is JScript. 
So, you can simply write anything that is allowed in JScript and this script will be operational.
For instance, in JScript and C++Script all variables and constants are VARIANT.
You must declare them and you should do this using the following format:
var p, w;
Syntax of C++ scripts is the same as the syntax of C# scripts (since C#Script is also based on JScript). 
They are the same as long as the scripts reside in TestComplete.
If you export scripts to a Connected Application, they will be different. 
That is, the syntax of C++Script and C#Script routines exported to C++ and C# Connected and Self-Testing Applications will differ.
Once again, the idea of having C++Scripts as a separate script language for TestComplete projects is to let developers, 
who are used to C++, write script code that requires minimal changes when being imported into C++ applications. 
When writing such code in C++Script, please keep in mind the following rules, which distinguish C++Script from JScript:
1.	When calling methods, use only the following notation: method names are quoted and placed in brackets, 
and their parameters are placed in parentheses:
C++Script
Log["Message"]("My Message", "My Message Description", 0, 1);
```



Дженкинс нужен для 

contiues Integration

автосбока

автокомпиляция 

Код закодили.
Его выкачивают через гит из ветки.
его компилят компилятором, или несколькими компиляторами
потом запускаются юнит тесты (юнит тесты пишутся разработчиками)



Понимание жизненного цикла ПО, разработки, тестирования

Роль тестирования в жизненном цикле разработки ПО
В первую очередь стоит отметить, что процесс тестирования ПО тесно связан непосредственно с процессом разработки.


### Жизненный цикл разработки состоит из следующих этапов:

1. Анализ требований
2. Дизайн
3. Разработка
4. Тестирование и дебаггинг
5. Эксплуатация и поддержка

https://xbsoftware.ru/blog/zhiznennyj-tsykl-testirovaniya-po-preimuschestva-shagi/

**ПОЧЕМУ ТАК ВАЖНО следовать Жизненному циклу ПО:**

**ПРИЧИНА И ПРИМЕР:** в жизни может произойти так: из 3-го этапа сразу в 5-тый.
Программист закодил фичу. Подумал, что закодил всё без ошибок.
Отдал заказчику, не стал из-за столь мелкой фичи беспокоить тестировщика.
Заказчик поставил прогу с Фичей, фича уронила ВСЁ приложение.

### Жизненный цикл Тестирования

Жизненный цикл тестирования наилучшим образом реализуется как процесс со многими итерациями. В каждом цикле итераций коллектив разработчиков программного обеспечения создает промежуточную версию компоновки, которая является потенциальным кандидатом для тестирования.

Цели и акценты разработчиков меняются в разных циклах итерации. Согласно этому должны строить свои планы и участники коллектива тестирования. Мы рекомендуем ограничивать до минимума усилия по планированию, а там, где они необходимы, привязывать их точно ко времени, когда они потребуются. Также мы рекомендуем планировать тестирование только для ближайшей итерации.

Для каждой компоновки в тесты будут вноситься добавления и уточнения, и что-то будет удаляться. Некоторые из тестов будут неизменными и будут включаться в комплект тестов, применяемый при тестировании каждой компоновки в жизненном цикле. При таком подходе тесты изменяются и уточняются, как и само программное обеспечение. Нет никакой фиксированной спецификации программного обеспечения, и сами тесты тоже не фиксированы. На рисунке показана схема развития тестов во времени.

Этот подход на основе итераций и архитектура на основе компонентов особенно подчеркивают целесообразность регрессионного тестирования качества продукта для каждого цикла компоновки. Все тесты, разработанные для версии X, являются потенциальными кандидатами для регрессионного тестирования версии X+1, X+2 и т.д. Когда тест повторяется несколько раз, возможно, его следует автоматизировать. Автоматизированное тестирование позволяет выполнять сценарии при повторном тестировании и переключать сотрудников на работу с тестированием новых функций.
Рассмотрим только жизненный цикл тестирования, пока не обращая внимания на остальные части проекта. На рисунке показана структура различных задач дисциплины тестирования в заданной итерации.

Основные артефакты тестирования


Знание методик тестирования;




Подготовка тест планов - тест кейсы

Написание модульных  автотестов
интеграционных автотестов
приемочных автотестов

Работа с тестовой документацией (Zephyr);

Работа в багтрекинговой системе (JIRA);

Работа с документацией (Confluence).

Требования
Высшее образование;

Опыт от 1 года в области тестирования;

Знание методик тестирования;

Базовые знания с++;

Базовые знание SQL;

Умение разбираться в чужом коде;

Понимание жизненного цикла ПО;

Желателен опыт работы с заказчиком;

Личностные качества: аккуратный, активный, инициативный, исполнительный, коммуникабельный, обязательный, ориентированный на результат, ответственный, работоспособный, самостоятельный.





### HOTKEYS
```
Ctrl + Shift + F - Выполнить поиск по всему проекту
Ctrl + H - заменить много где во всём файле
Alt - Горизонтальное выделение квадратом и редактирование Квадратом
Ctrl + Shift + Left / Ctrl + Shift + Right - Выделить целое слово (без пробелов)

Alt + Tab - переключение между окнами
Alt + F4 - Закрыть окно/приложение

Ctrl + F - Запустить Поиск по слову
Crtl + L - Перейти к адресной строке проводника в ОС или в Браузере.
F5 - Обновить окно проводника или Браузера 
Backspace - Перейти на уровень вверх (назад) в окне проводника или Браузера.

F2 - переименовать файл / папку
Выдекление / Перетаскивания с Shift - выделение сразу множества объектов стоящих 
					рядом по горизонтали и вертикали или прямоугольным-блоком
Выдекление / Перетаскивания с Ctrl - выделение нескольких объектов но расположенных где угодно

Insert !!!
Переключение нра цифровую клаиватуру Num Lock !!!

Ctrl + A - выделить всю строку целиком от начала до конца
Ctrl + C - скопировать выделенный текст/файл/папку
= Ctrl + V - вставить выделенный текст/файл/папку
= Shift + Insert - вставить выделенный текст/файл/папку
Ctrl + X - вырезать выделенный текст/файл/папку
Ctrl + S - сохранить изменения в файле
Ctrl + Z - "Шаг Назад" - в любой программе и в операционной системе. Обращает последнее действие
Ctrl + Y - "Шаг Вперёд" - в любой программе и в операционной системе. Повторяет последнее обращённое действие

Ctrl + Alt + Del - Вызов в окна с опциями - 
Ctrl + Shift + Escape

Alt + Tab - переход между запущенными приложениями
Ctrl + T - В БРАУЗЕРЕ - открыть новую вкладку
Ctrl + N - В БРАУЗЕРЕ - открыть новую страницу 
Ctrl + Shift + N - содать новую папку

Win commands
Win + R - Вызвать окно "ВЫПОЛНИТЬ"
Win + E - открыть Мой компьютер
Win + Pause - Параметры системы
Win + L - Выйти из учётной записи / Заблокировать текущую учётную запись 
		выйцти в окно ввода логина и пароля

Switch between CPP and H
MSVS:	Ctrl + K + O 
Qt:		F4
```

### WIN COMMAND LINE COMMANDS
```
Win commands
Win + R - Вызвать окно "ВЫПОЛНИТЬ"

Команды которые можно выполнить в окне "ВЫПОЛНИТЬ":
cmd - запуск командной строки
notepad - блокнот
mspaint - пейнт
calc - калькулятор
explorer - Проводник Windows
inetmgr - Диспетчер служб ISS
services.msc - Список Служб / Windows Services
regedit - открыть окно Реестра Windows
powershell - Более модернизированная командная строка
msconfig - Конфигурация системы + Автозагрузки
diskmgmt.msc - Управление жёсткими дисками
```

### Git / Svn commands
```
+ clone - склонировать репозиторий - клонировать
+ add - добавить файлы к коммиту - добавить
+ commit - зафиксировать изменения - зафиксировать
+ pull - затянуть с сервера - тянуть
+ push - загрузить на сервер - толкать

* branch - создать новую ветку  - ветка / ответвление
* merge - слиться с какой-то веткой / слить свою ветку с чье-то - слияние
* checkout - перейти на ветку - проверить
* revert = checkout - обратить изменения
* rebase - ОПАСНОЕ - переместить стартовую точку ветки на коммит на котором мы сейчас находимся
* fetch - загрузить себе последние изменения от всех кто комитил и пушил, НО свою ветку мы не "
		подтягиваем" до последнего коммита, если в нашу ветку кто-то комитил по мимо нас

status - посмотреть в какой мы сейчас ветке + показать последние изменения в актуальном коммите
log - посмотреть все коммиты в рамках данной ветки в виде истории изменений
reset - это сложный универсальный инструмент для отмены изменений. 
	Она имеет три основные формы вызова, соответствующие 
	аргументам командной строки --soft, --mixed, --hard. (пример: git reset --hard)
remote - запросить данные на сервере (!!!)
stash - спрятать наши изменения для дальнейшего коммита
```

```
git config --global user.email "you111@mail.com"
git config --global user.name "You111"

git add (имя файла в котором произошли изменения)
git add index.html - файл в котором были изменения в примере

git commit -m "comment 3"


Закомитить изменения у себя - делается в дыва шага
1. git add
2. git commit -m "(комментарий)"

Отправить изменения на сервер git push
Получить изменения с сервера git pull

Вывести весь список доступный веток
git branch -a

Перейти в ветку
git checkout (имя ветки)

Создать новую ветку
git branch (имя ветки)

Загрузить себе все изменения которые произошли во всех ветках,
но не произойдет гир пул (в ветку на которой мы сейчас находимся 
не загрузится ее последнее состояние (последний коммит)
git fetch


git merge (ветка которую мы хотим влить в себя)


git clone ИМЯ_РЕПОЗИТОРИЯ

git add ФАЙЛ_С_ИЗМЕНЕНИЯМИ
git commit -m "COMMENT"

git push
git pull
```



### Software
https://github.com/chizhonk/interview_preparation_kit
### All
https://github.com/chaotism/handbook
https://www.kobzarev.com/wp-content/uploads/books/php/PHPbook.pdf
### Testing
https://github.com/VladislavEremeev/QA_bible/blob/master/Manual%20part%201.md

```
ССЫЛКА
КНОПКА
НАДПИСЬ
```

# Команды Linux
```
2. grep command examples
Search for a given string in a file (case in-sensitive search).
$ grep -i "the" demo_file

Что делает команда grep?
Поиск шаблона в строке или файле довольно просто выполнить с помощью команды grep. Эта команда выполняется, когда необходимо найти конкретную комбинацию символов. Grep-фильтр ищет один или несколько файлов в соответствии с пользовательской командой для поиска текстовых строк с использованием любого выражения.

Команда Grep – это выражение, используемое для фильтрации результатов или вывода.
Например, чтобы вывести список каталогов и искать только файлы со словом «cron», выполните команду:
ls | grep cron

3. find command examples
Find files using file-name ( case in-sensitve find)
# find -iname "MyCProgram.c"

4. ssh command examples
Login to remote host
ssh -l jsmith remotehost.example.com

Что делает команда env?
Команда env – это shell-команда, которая может использоваться для вывода списка существующих переменных среды или для запуска другой программы в пользовательской среде без изменения текущей.

Что значит chmod + x FILENAME?
Команда chmod – это сокращение от Change Mode. Эта команда чрезвычайно полезна для изменения прав доступа к файлам и папкам, расположенным в Linux/Unix. Разрешение на доступ к файлу/каталогу, которое обычно является записью, чтением или выполнением для любого пользователя или группы.

touch file1.doc
- создать файл

cat - вывод содержимого файла в консоль

ls - вывести список каталогов
ls command examples
Display filesize in human readable format (e.g. KB, MB etc.,)

chmod - сменитиь права доступа для файл / папки

cd command examples

les

man - вызвать документацию линукс на что угодно

ps -

free - 
kill  - убить процесс

rm - удалить 
cp - скоприровать 
mv - переместить
```


				
Тестировщики на реальной работе занимаются:
- пишут документы ТЗ, ТестКейсы, Тестпланы, ЧекЛисты
- продумывают тесты по ненаписнному ПО по ТЗ и пишут тесты по реализованному ПО
- тестеры тестят ПО

Как тестировать Карандаш, тостер, банкомат, мост, аппарат проающий бутылки воды
https://www.youtube.com/watch?v=Erctsy6i0zo


Сценарий тестирования "Окно Авторизации"
* Функционал: "Окно Авторизации"
* Шаги:
- вводим логин пользователя
- вводим пароль пользователя
- ставим галочку, что мы не админисратор
- жмём кнопку войти
* Ожидаемый результат
Происходи пререход на страницу пользователя

Для Сценария тестирования "Окно Авторизации"
Тестовые Входные данные 
логин: ivan
пароль: qwerty

Тестовый скрипт:
- вводим логин пользователя ivan
- вводим пароль пользователя qwerty
- ставим галочку, что мы не админисратор
- жмём кнопку войти
```
  var p, w;
  p = Sys["Process"]("MFCApplication1");
  w = p["Window"]("MFCApplication1");
  w["Activate"]();
  w["Window"]("Button")("IDOK")["Click"];
  w["Window"]("Edit")["VScroll"]["Pos"] = 0;
  w["Window"]("Edit")["Click"](9, 9);
  Sys["Keys"]("Test");
  w["MainMenu"]["Click"]("File|Exit");
```
 

# Git

### Разница между pull и fetch

### Разница между merge and rebase


# SQL

- Когда выполняется Селект из как минимум двух таблиц,
то необходимо у этих таблиц найти общий "по смыслу"/"содержанию" столбец
и дописать условие для таблиц по этим столбцам соотвественно

https://tproger.ru/articles/sql-interview-questions/

# ТИПИЧНЫЙ Вопрос с селектом:
Select *
FROM A , B

# ТИПИЧНЫЙ Вопрос:
Обычный JOIN это какой JOIN
Ответ = INNER JOIN

# ТИПИЧНЫЙ Вопрос:
Написать SQL – запрос для отображения текущей даты.
Ответ: SQL имеет встроенную функцию под названием GetDate(), которая возвращает текущую временную метку. Это будет работать в Microsoft SQL Server, другие производители, такие как Oracle и MySQL также имеет эквивалентные функции.
SELECT GetDate();

# 1ая,2ая,3я,4ая,5ая,6-тая НОРМАЛЬНЫЕ ФОРМЫ БД
НОРМАЛЬНЯ ФОРМА / НОРМАЛИЗАЦИЯ БД - требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

# 1-ая НОРМАЛЬНАЯ ФОРМА:
- https://info-comp.ru/database-normalization
СУТЬ: В таблице в каждой ячейке должна всегда быть ОДНА сущность, не доуспкается перечислений.
ПЛОХАЯ БД:

|Фирма 	|Модели     |
 ------ | ----------
|BMW 	|M5, X5M, M1|
|Nissan |	GT-R|

Для моделей BMW, в одной ячейке содержится список из 3 элементов: M5, X5M, M1. 1 запись = 1 сущность, а тут в 1 яцейке их три

Преобразуем таблицу к 1НФ:

|Фирма 	|Модели|
------- | ------
|BMW 	|M5    |
|BMW 	|X5M   |
|BMW 	|M1    |
|Nissan |GT-R  |

# 2-ая НОРМАЛЬНАЯ ФОРМА
https://info-comp.ru/second-normal-form

# 3-ТЬЯ НОРМАЛЬНАЯ ФОРМА
https://info-comp.ru/third-normal-form


https://andreyex.ru/bazy-dannyx/uchebnoe-posobie-po-sql/14-naibolee-chasto-ispolzuemyx-zaprosov-sql-vopros-otvet/

https://habr.com/ru/post/181033/



https://ppt-online.org/146233




### English 
```
new [нью] - новый
old [олд] - старый
size [сайз] - размер
next [некст] - следующий / Далее
back [бэк] - назад / спина
previous [привэос] - предыдущий
data [дэйта] - данные
add [эд] - добавить
delete [делит] - удалить
step [стэп] - шаг
open [оупэн] - открыть
close [клоуз] - закрыть
save [сейв] - сохранить
load [лоад] - загрузить
option [опшн] - настройка, опция, вариант
propertie [проперти] - свойство
download [даунлоад] - скачать
upload [аплоад] - загрузить

who ? [ху] - кто
what ? [уот] - что
when ? [уэн] - когда
why ? [уай] - полчему
how ? [хау] - как
whom ? [хум] - кому
about [эбаут] - о (чём-то / ком-то)

and [энд] - и
bool [бул] - булева
break [брэйк] - разбить
case [кейс] - случай
catch [кеч] - поймать / ловить
character [чарактэр] - символ, персонаж
cast [каст] - перевести (выполнить перевод из одного сосот. в другое)
continue [континью] - продолжить
default [дефолт] - стандартный / по умолчанию
delete [делит] - удалить
do [ду] - делать
double [дабл] - двойной / удвоенный
dynamic [дайнэмик] - динамический
else [элс] - иначе
export [экспорт] - экспортировать
extern [экстерн] - внешний
false [фолс] - ЛОЖЬ
float [флоат] - 
for [фор] - для
go to [гоу ту] - идити в
if [иф] - если
integer [интеджер] - целое (всмысле не дробное, про число)
name [нейм] - имя
space [спейс] - пробел, пространство
new [нью] - новый
pointer [поинтер] - указатель
private [прайвет] - приватный
protected [протектед] - защищённый
public [паблик] - публичный
return [ретёрн] - вернуть
short [шорт] - короткий
sign [сайн] - знак
signed [сайнт] - знаковый
size of [сайз оф] - размер (чего-то)
structure [страчер] - структура
switch [свич] - переключиться
template [темплейт] - шаблон
this [Зис] - это
thread [тред] - поток
local [локал] - локал
throw [фроу] - бросать
true [тру] - ИСТИНА
try [трай] - попытаться
type [тайп] - тип
union [юнион] - объединение
unsigned [ансайнт] - беззнаковый
use [юз] - использовать
using [юзинг] - используя
while [уайл] - во то время как

function [фанкшн] - функция
jump [джамп] - прыгать
big [биг] - большой
small [смол] - маленький
little [литл] - маленький
edit [эдит] - менять
deny [денай] - отменить
enable [энейбл] - задействовать
deprecated [деприкэйтед] - устаревший
call [кол] - вызвать, вызов
substract [сабстракт] - отнять / уменьшить
multiply [мультиплай] - умножить
erase [ирэйз] - стереть = удалить

add [эд] - добавить
insert [инсерт] - вставить
select [селект] - выбирать
new [нью] - создать

complete [комплит] - закончить / завершить / готов
incomplete [инкомплит] - незаконченный / незавершенный / неготов
different [дифферент] - другой / иной
difference [дифференс] - разница
algorythm [элгоритм] - алгоритм
compare [кмпэар] - сравнивать
read [рид] - читать
write [райт] - писать
access [эксэс] - доступ
word [ворд] - слово
last [лэст] - последний
first [фёрст] - первый
begin [бегин] - начало / начинать
end [энд] - конец / заканчивать
create [криэйт] - создавать
destroy [дестрой] - уничтожать
total [тотал] - полный / полностью
location [локэйшн] - место / позиция
recent[рисэнт] - текущий / настоящий
print [принт] - печатать
all [ол] - все
both [боуф] - оба
side [сайд] - сторона
letter [лэттэр] - письмо
preview [привью] - предпросмотр
attach [эттач] - вложение
share [шэр] - менять / обменивать / показывать / делиться
save [сэйв] - сохранять
load [лоад] - загружать
change [чейндж] - изменять
support [сапорт] - поддерживать
tool [тул] - инструмент
Check [чек] - проверять
Paste [пэйст] - Вставить
Cut [кат] - Вырезать
Font [фонт] - Шрифт
Color [колор] - Цвет 
Show [шоу] - показывать
Increase [инкриз] - увеличивать
Decrease [дериз] - уменьшать
Change [чейндж] - изменять
Find [файнд] - найти
Replace [реплэйс] - заменять / менять местами
Select [селект] - выбирать
Shape [шэйп] - форма
Blank [блэнк] - Пустая
Link [линк] - Ссылка
Header [хэдэр] - заголовок
Equation [экуэйжн] - выражение

Margin [маргин] - Поле
Page [пэйдж] - Страница
Line [лайн] - строка
Column [колам] - столбец
Column [колам] - Колонка
Even [ивэн] - Четная
Odd [од] - Нечетная
Left [лэфт] - Слева
Right [рфйт] - Справа
Before [бефор] - До
After [афтэр] - После 
Position [позишн] - Положение
Bring [бринг] - принести
Forward [форворд] - вперед
Backward [бэкворд] - назад 
Send [сэнд] - отправить 
Pane [пээн] - Область
Align [элайн] - Выровнять
Rotate [ротэйт] - Повернуть
angle [энгл] - угол
Mark [марк] - Пометить
Entry [энтри] - элемент
Note [ноут] - Показать сноски
Style [стайл] - Стиль
List [лист] - список
Rule [рул] - Правила
Field [фиилд] -  поле
Merge [мёрдж] - объединить
Split [сплит] - Разделить 

help [хэлп] - помогите, помогать, помощь
tab [тэб] - вкладка
home [хоум] - дом
push [пуш] - нажать, давить
page [пэйдж] - страница
reference [референс] - ссылка
mail [мэйл] - почта
view [вью] - вид, представление
review [ревью] - обзор
title [тайтл] - надпись
point [поинт] - точка
button [баттон] - кнопка
box [бокс] - коробка
scroll [скрол] - Ползунок
scroll box [скрол бокс] - Ползунок прокрутки
zoom [зум] - прибилжать
send [сэнд] - отправлять
recieve [ресив] - получать
layout [лэйаут] - разметка / схема / макет
label [лэйбл] - надпись
save [сэйв] - сохранить
save as [сэйв эз] - сохранить как
open [оупен] - открыть
close [клоуз] - закрыть
info [инфо] - сведения
recent [рисэнт] - последние
print [принт] - печать
options [опшн] - параметры
exit [экзит] - Выход

Window [уиндоу] - окно
Comment [коммент] - Примечание, Комментарии
Change [чейндж] - изменять
Accept [эксэпт] - принимать
Protect [протэкт] - защищать
Block [блок] - блокировать
Restrict [рестрикт] - запрещать / оагрничивать
Record [рекорд] - записывать
Security [секьюрити] - безопасность
Drop [дроп] - бросать
Pick [пик] - выбирать
Frame [фрэйм] - рамка 
Reset [рисэт] - перезагружать / перезапускать
Image [имэйдж] - изображение
Mode [моуд] - Режим 
Group [груп] - Группи
Schema [шэма] - Схема
Template [тэмплейт] - Шаблоны
Border [бордэр] - Границы
Pen [пэн] - перо
Style [стайл] - Стиль 
Weight [вэйт] - Толщина 
Height [хэйт] - Высота 
Widht [уидт] - Ширина 
Draw [дроу] - рисовать
Table [тэйбл] - Нарисовать таблицуэ
Eraser [эрэйзр] - Ластик
Fit [фит] - Автоподбор
Align [элайн] - Выровнять 
Repeat [рипит] - Повторить 
Convert [ковёрт] - Преобразовать 
Adjust [эджаст] - применять
Background [бэкграунд] - фон
Compress [компрэс] - сжимать
Wrap [урэп] - сворачивать / обёртка
Arrange [эррэйндж] - выстраивать / подстроить

Layout [лэйаут] - Макет 
Crop [кроп] - Обрезка

Forward [форвуард] - вперёд
Backward [бэквуард] - фон
Fill [фил] - заполнить
Outline [аутлайн] - контур
Direction [дайрекшн] - напрвление
Shape [шэйп] - Фигуры
Picture [пикчэр] - Рисунок
Axe [экс] - Оси
Wall [уол] - Стенка
Area [эриа] - Область
Background [бэкграунд] - Фон
Up [ап] - над / наверх / наверху
Down [даун] - вниз / внизу
under [андэр] - под
over [оувэр] - над
Error [эррор] - ошибка
exception [эксэпшн] - исключение

point [поинт] - точка
line [лайн] - линия
polyline [полилайн] - многоугольная линия / ломаная
ellipse [эллипс] - элипс
circle [сиркл] - круг
rectangle [рэктэнгл] - прямоугольник
square [скуэар] - квадрат
triangle [трайэнгл] - треугольник
angle [энгл] - кгол
side [сайд] - сторона
polygon [полигон] - многоугольник

select [селект] - выбирать
insert [инсерт] - вставлять
update [апдейт] - обновлять
delete [делит] - удалять

include [инклуд] - вставлять
import [импорт] - подключать
return [ретёрн] - возвращать

memory [мэмори] - память
drive [драйв] - водить авто
sound [саунд] - звук
unique [юник] -  уникальный
description [дескрипшн] - описание
display [дисплэй] - отображать
launch [лаунч] - запускать
crash [скэр] - крах / авария / аварийное завершение
fall [фол] - падение
settings [сэттингз] - настройки
amount [эмаунт] - количество
must [маст] - должен
disable [дисэйбл] - отключать
prefear [прифэар] - предпочитать
count [каунт] - считать / пересчитывать / количество
engine [энджин] - двигатель / средство / инструмент
core [кор] - ядро
current [каррэнт] - текущий / данный
device [девайс] - устройство
brows [брауз] - одалживать
advanced [эдвансд] - дополнительно
direct [дайрект] - непосредственно / прямо / точно
custom [кастом] - определённая
сompatibillity [компатибилити] - совместимость
show [шоу] - показывать
with [уизтх] - с
specify [специфити] - указывать / уточнять
present [презент] - настоящий / имеющийся в наличии
allow [эллау] - допускать / дозволять
any [эни] - любой / каждый
```

